{"version":3,"file":"prisma-ast.cjs.production.min.js","sources":["../src/lexer.ts","../src/getConfig.ts","../src/parser.ts","../src/schemaUtils.ts","../src/visitor.ts","../src/getSchema.ts","../src/schemaSorter.ts","../src/printSchema.ts","../src/PrismaSchemaBuilder.ts"],"sourcesContent":["import { createToken, Lexer, IMultiModeLexerDefinition } from 'chevrotain';\n\nexport const Identifier = createToken({\n  name: 'Identifier',\n  pattern: /[a-zA-Z]\\w*/,\n});\nexport const Datasource = createToken({\n  name: 'Datasource',\n  pattern: /datasource/,\n  push_mode: 'block',\n});\nexport const Generator = createToken({\n  name: 'Generator',\n  pattern: /generator/,\n  push_mode: 'block',\n});\nexport const Model = createToken({\n  name: 'Model',\n  pattern: /model/,\n  push_mode: 'block',\n});\nexport const View = createToken({\n  name: 'View',\n  pattern: /view/,\n  push_mode: 'block',\n});\nexport const Enum = createToken({\n  name: 'Enum',\n  pattern: /enum/,\n  push_mode: 'block',\n});\nexport const True = createToken({\n  name: 'True',\n  pattern: /true/,\n  longer_alt: Identifier,\n});\nexport const False = createToken({\n  name: 'False',\n  pattern: /false/,\n  longer_alt: Identifier,\n});\nexport const Null = createToken({\n  name: 'Null',\n  pattern: /null/,\n  longer_alt: Identifier,\n});\nexport const Comment = createToken({\n  name: 'Comment',\n  pattern: Lexer.NA,\n});\n\nexport const DocComment = createToken({\n  name: 'DocComment',\n  pattern: /\\/\\/\\/\\s*(.+)/,\n  categories: [Comment],\n});\nexport const LineComment = createToken({\n  name: 'LineComment',\n  pattern: /\\/\\/\\s*(.+)/,\n  categories: [Comment],\n});\nexport const Attribute = createToken({\n  name: 'Attribute',\n  pattern: Lexer.NA,\n});\nexport const BlockAttribute = createToken({\n  name: 'BlockAttribute',\n  pattern: /@@/,\n  label: \"'@@'\",\n  categories: [Attribute],\n});\nexport const FieldAttribute = createToken({\n  name: 'FieldAttribute',\n  pattern: /@/,\n  label: \"'@'\",\n  categories: [Attribute],\n});\nexport const Dot = createToken({\n  name: 'Dot',\n  pattern: /\\./,\n  label: \"'.'\",\n});\nexport const QuestionMark = createToken({\n  name: 'QuestionMark',\n  pattern: /\\?/,\n  label: \"'?'\",\n});\nexport const LCurly = createToken({\n  name: 'LCurly',\n  pattern: /{/,\n  label: \"'{'\",\n});\nexport const RCurly = createToken({\n  name: 'RCurly',\n  pattern: /}/,\n  label: \"'}'\",\n  pop_mode: true,\n});\nexport const LRound = createToken({\n  name: 'LRound',\n  pattern: /\\(/,\n  label: \"'('\",\n});\nexport const RRound = createToken({\n  name: 'RRound',\n  pattern: /\\)/,\n  label: \"')'\",\n});\nexport const LSquare = createToken({\n  name: 'LSquare',\n  pattern: /\\[/,\n  label: \"'['\",\n});\nexport const RSquare = createToken({\n  name: 'RSquare',\n  pattern: /\\]/,\n  label: \"']'\",\n});\nexport const Comma = createToken({\n  name: 'Comma',\n  pattern: /,/,\n  label: \"','\",\n});\nexport const Colon = createToken({\n  name: 'Colon',\n  pattern: /:/,\n  label: \"':'\",\n});\nexport const Equals = createToken({\n  name: 'Equals',\n  pattern: /=/,\n  label: \"'='\",\n});\nexport const StringLiteral = createToken({\n  name: 'StringLiteral',\n  pattern: /\"(:?[^\\\\\"\\n\\r]|\\\\(:?[bfnrtv\"\\\\/]|u[0-9a-fA-F]{4}))*\"/,\n});\nexport const NumberLiteral = createToken({\n  name: 'NumberLiteral',\n  pattern: /-?(0|[1-9]\\d*)(\\.\\d+)?([eE][+-]?\\d+)?/,\n});\nexport const WhiteSpace = createToken({\n  name: 'WhiteSpace',\n  pattern: /\\s+/,\n  group: Lexer.SKIPPED,\n});\nexport const LineBreak = createToken({\n  name: 'LineBreak',\n  pattern: /\\n|\\r\\n/,\n  line_breaks: true,\n  label: 'LineBreak',\n});\n\nconst naTokens = [Comment, DocComment, LineComment, LineBreak, WhiteSpace];\n\nexport const multiModeTokens: IMultiModeLexerDefinition = {\n  modes: {\n    global: [...naTokens, Datasource, Generator, Model, View, Enum],\n    block: [\n      ...naTokens,\n      Attribute,\n      BlockAttribute,\n      FieldAttribute,\n      Dot,\n      QuestionMark,\n      LCurly,\n      RCurly,\n      LSquare,\n      RSquare,\n      LRound,\n      RRound,\n      Comma,\n      Colon,\n      Equals,\n      True,\n      False,\n      Null,\n      StringLiteral,\n      NumberLiteral,\n      Identifier,\n    ],\n  },\n  defaultMode: 'global',\n};\n\nexport const PrismaLexer = new Lexer(multiModeTokens);\n","import type { IParserConfig } from 'chevrotain';\nimport {\n  lilconfigSync as configSync,\n  type LilconfigResult as ConfigResultRaw,\n} from 'lilconfig';\n\nexport interface PrismaAstConfig {\n  parser: Pick<IParserConfig, 'nodeLocationTracking'>;\n}\n\ntype ConfigResult<T> = Omit<ConfigResultRaw, 'config'> & {\n  config: T;\n};\n\nconst defaultConfig: PrismaAstConfig = {\n  parser: { nodeLocationTracking: 'none' },\n};\n\nlet config: PrismaAstConfig;\nexport default function getConfig(): PrismaAstConfig {\n  if (config != null) return config;\n\n  const result: ConfigResult<PrismaAstConfig> | null =\n    configSync('prisma-ast').search();\n  return (config = Object.assign(defaultConfig, result?.config));\n}\n","import { CstParser } from 'chevrotain';\nimport getConfig from './getConfig';\nimport * as lexer from './lexer';\n\ntype ComponentType = 'datasource' | 'generator' | 'model' | 'view' | 'enum';\nexport class PrismaParser extends CstParser {\n  constructor() {\n    super(lexer.multiModeTokens, getConfig().parser);\n    this.performSelfAnalysis();\n  }\n\n  private break = this.RULE('break', () => {\n    this.CONSUME1(lexer.LineBreak);\n    this.CONSUME2(lexer.LineBreak);\n  });\n\n  private keyedArg = this.RULE('keyedArg', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'keyName' });\n    this.CONSUME(lexer.Colon);\n    this.SUBRULE(this.value);\n  });\n\n  private array = this.RULE('array', () => {\n    this.CONSUME(lexer.LSquare);\n    this.MANY_SEP({\n      SEP: lexer.Comma,\n      DEF: () => {\n        this.SUBRULE(this.value);\n      },\n    });\n    this.CONSUME(lexer.RSquare);\n  });\n\n  private func = this.RULE('func', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'funcName' });\n    this.CONSUME(lexer.LRound);\n    this.MANY_SEP({\n      SEP: lexer.Comma,\n      DEF: () => {\n        this.OR([\n          { ALT: () => this.SUBRULE(this.keyedArg) },\n          { ALT: () => this.SUBRULE(this.value) },\n        ]);\n      },\n    });\n    this.CONSUME(lexer.RRound);\n  });\n\n  private value = this.RULE('value', () => {\n    this.OR([\n      { ALT: () => this.CONSUME(lexer.StringLiteral, { LABEL: 'value' }) },\n      { ALT: () => this.CONSUME(lexer.NumberLiteral, { LABEL: 'value' }) },\n      { ALT: () => this.SUBRULE(this.array, { LABEL: 'value' }) },\n      { ALT: () => this.SUBRULE(this.func, { LABEL: 'value' }) },\n      { ALT: () => this.CONSUME(lexer.True, { LABEL: 'value' }) },\n      { ALT: () => this.CONSUME(lexer.False, { LABEL: 'value' }) },\n      { ALT: () => this.CONSUME(lexer.Null, { LABEL: 'value' }) },\n      { ALT: () => this.CONSUME(lexer.Identifier, { LABEL: 'value' }) },\n    ]);\n  });\n\n  private property = this.RULE('property', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'propertyName' });\n    this.CONSUME(lexer.Equals);\n    this.SUBRULE(this.value, { LABEL: 'propertyValue' });\n  });\n\n  private assignment = this.RULE('assignment', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'assignmentName' });\n    this.CONSUME(lexer.Equals);\n    this.SUBRULE(this.value, { LABEL: 'assignmentValue' });\n  });\n\n  private field = this.RULE('field', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'fieldName' });\n    this.SUBRULE(this.value, { LABEL: 'fieldType' });\n    this.OPTION1(() => {\n      this.OR([\n        {\n          ALT: () => {\n            this.CONSUME(lexer.LSquare, { LABEL: 'array' });\n            this.CONSUME(lexer.RSquare, { LABEL: 'array' });\n          },\n        },\n        { ALT: () => this.CONSUME(lexer.QuestionMark, { LABEL: 'optional' }) },\n      ]);\n    });\n    this.MANY(() => {\n      this.SUBRULE(this.attribute, { LABEL: 'attributeList' });\n    });\n    this.OPTION2(() => {\n      this.CONSUME(lexer.Comment, { LABEL: 'comment' });\n    });\n  });\n\n  private block = this.RULE(\n    'block',\n    (\n      options: {\n        componentType?: ComponentType;\n      } = {}\n    ) => {\n      const { componentType } = options;\n      const isEnum = componentType === 'enum';\n      const isObject = componentType === 'model' || componentType === 'view';\n\n      this.CONSUME(lexer.LCurly);\n      this.CONSUME1(lexer.LineBreak);\n      this.MANY(() => {\n        this.OR([\n          { ALT: () => this.SUBRULE(this.comment, { LABEL: 'list' }) },\n          {\n            GATE: () => isObject,\n            ALT: () => this.SUBRULE(this.property, { LABEL: 'list' }),\n          },\n          { ALT: () => this.SUBRULE(this.attribute, { LABEL: 'list' }) },\n          {\n            GATE: () => isObject,\n            ALT: () => this.SUBRULE(this.field, { LABEL: 'list' }),\n          },\n          {\n            GATE: () => isEnum,\n            ALT: () => this.SUBRULE(this.enum, { LABEL: 'list' }),\n          },\n          {\n            GATE: () => !isObject,\n            ALT: () => this.SUBRULE(this.assignment, { LABEL: 'list' }),\n          },\n          { ALT: () => this.SUBRULE(this.break, { LABEL: 'list' }) },\n          { ALT: () => this.CONSUME2(lexer.LineBreak) },\n        ]);\n      });\n      this.CONSUME(lexer.RCurly);\n    }\n  );\n\n  private enum = this.RULE('enum', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'enumName' });\n    this.OPTION(() => {\n      this.CONSUME(lexer.Comment, { LABEL: 'comment' });\n    });\n  });\n  private attribute = this.RULE('attribute', () => {\n    this.OR1([\n      {\n        ALT: () =>\n          this.CONSUME(lexer.BlockAttribute, { LABEL: 'blockAttribute' }),\n      },\n      {\n        ALT: () =>\n          this.CONSUME(lexer.FieldAttribute, { LABEL: 'fieldAttribute' }),\n      },\n    ]);\n    this.OR2([\n      {\n        ALT: () => {\n          this.CONSUME1(lexer.Identifier, { LABEL: 'groupName' });\n          this.CONSUME(lexer.Dot);\n          this.CONSUME2(lexer.Identifier, { LABEL: 'attributeName' });\n        },\n      },\n      {\n        ALT: () => this.CONSUME(lexer.Identifier, { LABEL: 'attributeName' }),\n      },\n    ]);\n\n    this.OPTION(() => {\n      this.CONSUME(lexer.LRound);\n      this.MANY_SEP({\n        SEP: lexer.Comma,\n        DEF: () => {\n          this.SUBRULE(this.attributeArg);\n        },\n      });\n      this.CONSUME(lexer.RRound);\n    });\n  });\n\n  private attributeArg = this.RULE('attributeArg', () => {\n    this.OR([\n      {\n        ALT: () => this.SUBRULE(this.keyedArg, { LABEL: 'value' }),\n      },\n      {\n        ALT: () => this.SUBRULE(this.value, { LABEL: 'value' }),\n      },\n    ]);\n  });\n\n  private component = this.RULE('component', () => {\n    const type = this.OR1([\n      { ALT: () => this.CONSUME(lexer.Datasource, { LABEL: 'type' }) },\n      { ALT: () => this.CONSUME(lexer.Generator, { LABEL: 'type' }) },\n      { ALT: () => this.CONSUME(lexer.Model, { LABEL: 'type' }) },\n      { ALT: () => this.CONSUME(lexer.View, { LABEL: 'type' }) },\n      { ALT: () => this.CONSUME(lexer.Enum, { LABEL: 'type' }) },\n    ]);\n    this.OR2([\n      {\n        ALT: () => {\n          this.CONSUME1(lexer.Identifier, { LABEL: 'groupName' });\n          this.CONSUME(lexer.Dot);\n          this.CONSUME2(lexer.Identifier, { LABEL: 'componentName' });\n        },\n      },\n      {\n        ALT: () => this.CONSUME(lexer.Identifier, { LABEL: 'componentName' }),\n      },\n    ]);\n\n    this.SUBRULE(this.block, {\n      ARGS: [{ componentType: type.image as ComponentType }],\n    });\n  });\n\n  private comment = this.RULE('comment', () => {\n    this.CONSUME(lexer.Comment, { LABEL: 'text' });\n  });\n\n  public schema = this.RULE('schema', () => {\n    this.MANY(() => {\n      this.OR([\n        { ALT: () => this.SUBRULE(this.comment, { LABEL: 'list' }) },\n        { ALT: () => this.SUBRULE(this.component, { LABEL: 'list' }) },\n        { ALT: () => this.SUBRULE(this.break, { LABEL: 'list' }) },\n        { ALT: () => this.CONSUME(lexer.LineBreak) },\n      ]);\n    });\n  });\n}\n\nexport const parser = new PrismaParser();\n","import type { CstNode, IToken } from 'chevrotain';\nimport getConfig from './getConfig';\nimport * as schema from './getSchema';\n\nconst schemaObjects = ['model', 'view'];\n\n/** Returns true if the value is an Object, such as a model or view. */\nexport function isSchemaObject(obj: schema.Object): boolean {\n  return obj != null && 'type' in obj && schemaObjects.includes(obj.type);\n}\n\n/** Returns true if the value is a Field. */\nexport function isSchemaField(field: schema.Field): boolean {\n  return field != null && 'type' in field && field.type === 'field';\n}\n\n/** Returns true if the value of the CstNode is a Token. */\nexport function isToken(node: [IToken] | [CstNode]): node is [IToken] {\n  return 'image' in node[0];\n}\n\n/**\n * If parser.nodeLocationTracking is set, then read the location statistics\n * from the available tokens. If tracking is 'none' then just return the\n * existing data structure.\n * */\nexport function appendLocationData<T extends Record<string, unknown>>(\n  data: T,\n  ...tokens: IToken[]\n): T {\n  const { parser } = getConfig();\n  if (parser.nodeLocationTracking === 'none') return data;\n\n  const location = tokens.reduce((memo, token) => {\n    if (!token) return memo;\n\n    const {\n      endColumn = -Infinity,\n      endLine = -Infinity,\n      endOffset = -Infinity,\n      startColumn = Infinity,\n      startLine = Infinity,\n      startOffset = Infinity,\n    } = memo;\n\n    if (token.startLine != null && token.startLine < startLine)\n      memo.startLine = token.startLine;\n    if (token.startColumn != null && token.startColumn < startColumn)\n      memo.startColumn = token.startColumn;\n    if (token.startOffset != null && token.startOffset < startOffset)\n      memo.startOffset = token.startOffset;\n\n    if (token.endLine != null && token.endLine > endLine)\n      memo.endLine = token.endLine;\n    if (token.endColumn != null && token.endColumn > endColumn)\n      memo.endColumn = token.endColumn;\n    if (token.endOffset != null && token.endOffset > endOffset)\n      memo.endOffset = token.endOffset;\n\n    return memo;\n  }, {} as IToken);\n\n  return Object.assign(data, { location });\n}\n","import { CstNode, IToken } from '@chevrotain/types';\nimport { parser } from './parser';\nimport * as Types from './getSchema';\nimport { appendLocationData, isToken } from './schemaUtils';\n\nconst BasePrismaVisitor = parser.getBaseCstVisitorConstructorWithDefaults();\nexport class PrismaVisitor extends BasePrismaVisitor {\n  constructor() {\n    super();\n    this.validateVisitor();\n  }\n\n  schema(ctx: CstNode & { list: CstNode[] }): Types.Schema {\n    const list = ctx.list?.map((item) => this.visit([item])) || [];\n    return { type: 'schema', list };\n  }\n\n  component(\n    ctx: CstNode & {\n      type: [IToken];\n      componentName: [IToken];\n      block: [CstNode];\n    }\n  ): Types.Block {\n    const [type] = ctx.type;\n    const [name] = ctx.componentName;\n    const list = this.visit(ctx.block);\n\n    const data = (() => {\n      switch (type.image) {\n        case 'datasource':\n          return {\n            type: 'datasource',\n            name: name.image,\n            assignments: list,\n          } as const;\n        case 'generator':\n          return {\n            type: 'generator',\n            name: name.image,\n            assignments: list,\n          } as const;\n        case 'model':\n          return { type: 'model', name: name.image, properties: list } as const;\n        case 'view':\n          return { type: 'view', name: name.image, properties: list } as const;\n        case 'enum':\n          return { type: 'enum', name: name.image, enumerators: list } as const;\n        default:\n          throw new Error(`Unexpected block type: ${type}`);\n      }\n    })();\n\n    return appendLocationData(data, type, name);\n  }\n\n  break(): Types.Break {\n    return { type: 'break' };\n  }\n\n  comment(ctx: CstNode & { text: [IToken] }): Types.Comment {\n    const [comment] = ctx.text;\n    const data = { type: 'comment', text: comment.image } as const;\n    return appendLocationData(data, comment);\n  }\n\n  block(ctx: CstNode & { list: CstNode[] }): Types.Block[] {\n    return ctx.list?.map((item) => this.visit([item]));\n  }\n\n  assignment(\n    ctx: CstNode & { assignmentName: [IToken]; assignmentValue: [CstNode] }\n  ): Types.Assignment {\n    const value = this.visit(ctx.assignmentValue);\n    const [key] = ctx.assignmentName;\n    const data = { type: 'assignment', key: key.image, value } as const;\n    return appendLocationData(data, key);\n  }\n\n  field(\n    ctx: CstNode & {\n      fieldName: [IToken];\n      fieldType: [CstNode];\n      array: [IToken];\n      optional: [IToken];\n      attributeList: CstNode[];\n      comment: [IToken];\n    }\n  ): Types.Field {\n    const fieldType = this.visit(ctx.fieldType);\n    const [name] = ctx.fieldName;\n    const attributes =\n      ctx.attributeList && ctx.attributeList.map((item) => this.visit([item]));\n    const comment = ctx.comment?.[0]?.image;\n    const data = {\n      type: 'field',\n      name: name.image,\n      fieldType,\n      array: ctx.array != null,\n      optional: ctx.optional != null,\n      attributes,\n      comment,\n    } as const;\n\n    return appendLocationData(data, name, ctx.optional?.[0], ctx.array?.[0]);\n  }\n\n  attribute(\n    ctx: CstNode & {\n      blockAttribute: [IToken];\n      fieldAttribute: [IToken];\n      groupName: [IToken];\n      attributeName: [IToken];\n      attributeArg: CstNode[];\n    }\n  ): Types.Attr {\n    const [name] = ctx.attributeName;\n    const [group] = ctx.groupName || [{}];\n    const args =\n      ctx.attributeArg && ctx.attributeArg.map((attr) => this.visit(attr));\n    const kind = ctx.blockAttribute != null ? 'object' : 'field';\n    const data = {\n      type: 'attribute',\n      name: name.image,\n      kind,\n      group: group.image,\n      args,\n    } as const;\n    const attrs = kind === 'object' ? ctx.blockAttribute : ctx.fieldAttribute;\n    return appendLocationData(data, name, ...attrs, group);\n  }\n\n  attributeArg(ctx: CstNode & { value: [CstNode] }): Types.AttributeArgument {\n    const value = this.visit(ctx.value);\n    return { type: 'attributeArgument', value };\n  }\n\n  func(\n    ctx: CstNode & { funcName: [IToken]; value: CstNode[]; keyedArg: CstNode[] }\n  ): Types.Func {\n    const [name] = ctx.funcName;\n    const params = ctx.value && ctx.value.map((item) => this.visit([item]));\n    const keyedParams =\n      ctx.keyedArg && ctx.keyedArg.map((item) => this.visit([item]));\n    const pars = (params || keyedParams) && [\n      ...(params ?? []),\n      ...(keyedParams ?? []),\n    ];\n    const data = { type: 'function', name: name.image, params: pars } as const;\n    return appendLocationData(data, name);\n  }\n\n  array(ctx: CstNode & { value: CstNode[] }): Types.RelationArray {\n    const args = ctx.value && ctx.value.map((item) => this.visit([item]));\n    return { type: 'array', args };\n  }\n\n  keyedArg(\n    ctx: CstNode & { keyName: [IToken]; value: [CstNode] }\n  ): Types.KeyValue {\n    const [key] = ctx.keyName;\n    const value = this.visit(ctx.value);\n    const data = { type: 'keyValue', key: key.image, value } as const;\n    return appendLocationData(data, key);\n  }\n\n  value(ctx: CstNode & { value: [IToken] | [CstNode] }): Types.Value {\n    if (isToken(ctx.value)) {\n      const [{ image }] = ctx.value;\n      return image;\n    }\n    return this.visit(ctx.value);\n  }\n\n  enum(\n    ctx: CstNode & { enumName: [IToken]; comment: [IToken] }\n  ): Types.Enumerator {\n    const [name] = ctx.enumName;\n    const comment = ctx.comment?.[0]?.image;\n    const data = { type: 'enumerator', name: name.image, comment } as const;\n    return appendLocationData(data, name);\n  }\n}\n","import { PrismaLexer } from './lexer';\nimport { PrismaVisitor } from './visitor';\nimport { parser } from './parser';\nimport type { CstNodeLocation } from 'chevrotain';\n\n/**\n * Parses a string containing a prisma schema's source code and returns an\n * object that represents the parsed data structure. You can make direct\n * modifications to the objects and arrays nested within, and then produce\n * a new prisma schema using printSchema().\n *\n * @example\n * const schema = getSchema(source)\n * // ... make changes to schema object ...\n * const changedSource = printSchema(schema)\n * */\nexport function getSchema(source: string): Schema {\n  const lexingResult = PrismaLexer.tokenize(source);\n  parser.input = lexingResult.tokens;\n  const cstNode = parser.schema();\n  if (parser.errors.length > 0) throw parser.errors[0];\n  const visitor = new PrismaVisitor();\n  return visitor.visit(cstNode);\n}\n\nexport interface Schema {\n  type: 'schema';\n  list: Block[];\n}\n\nexport type Block =\n  | Model\n  | View\n  | Datasource\n  | Generator\n  | Enum\n  | Comment\n  | Break;\n\nexport interface Object {\n  type: 'model' | 'view';\n  name: string;\n  properties: Array<Property | Comment | Break>;\n}\n\nexport interface Model extends Object {\n  type: 'model';\n  location?: CstNodeLocation;\n}\n\nexport interface View extends Object {\n  type: 'view';\n  location?: CstNodeLocation;\n}\n\nexport interface Datasource {\n  type: 'datasource';\n  name: string;\n  assignments: Array<Assignment | Comment | Break>;\n  location?: CstNodeLocation;\n}\n\nexport interface Generator {\n  type: 'generator';\n  name: string;\n  assignments: Array<Assignment | Comment | Break>;\n  location?: CstNodeLocation;\n}\n\nexport interface Enum {\n  type: 'enum';\n  name: string;\n  enumerators: Array<Enumerator | Comment | Break>;\n  location?: CstNodeLocation;\n}\n\nexport interface Comment {\n  type: 'comment';\n  text: string;\n}\n\nexport interface Break {\n  type: 'break';\n}\n\nexport type Property = GroupedBlockAttribute | BlockAttribute | Field;\n\nexport interface Assignment {\n  type: 'assignment';\n  key: string;\n  value: Value;\n}\n\nexport interface Enumerator {\n  type: 'enumerator';\n  name: string;\n  value?: Value;\n  comment?: string;\n}\n\nexport interface BlockAttribute {\n  type: 'attribute';\n  kind: 'object' | 'view';\n  group?: string;\n  name: string;\n  args: AttributeArgument[];\n  location?: CstNodeLocation;\n}\n\nexport type GroupedBlockAttribute = BlockAttribute & { group: string };\n\nexport interface Field {\n  type: 'field';\n  name: string;\n  fieldType: string | Func;\n  array?: boolean;\n  optional?: boolean;\n  attributes?: Attribute[];\n  comment?: string;\n  location?: CstNodeLocation;\n}\n\nexport type Attr =\n  | Attribute\n  | GroupedAttribute\n  | BlockAttribute\n  | GroupedBlockAttribute;\n\nexport interface Attribute {\n  type: 'attribute';\n  kind: 'field';\n  group?: string;\n  name: string;\n  args?: AttributeArgument[];\n  location?: CstNodeLocation;\n}\n\nexport type GroupedAttribute = Attribute & { group: string };\n\nexport interface AttributeArgument {\n  type: 'attributeArgument';\n  value: KeyValue | Value | Func;\n}\n\nexport interface KeyValue {\n  type: 'keyValue';\n  key: string;\n  value: Value;\n}\n\nexport interface Func {\n  type: 'function';\n  name: string;\n  params: Value[];\n}\n\nexport interface RelationArray {\n  type: 'array';\n  args: string[];\n}\n\nexport type Value =\n  | string\n  | number\n  | boolean\n  | Func\n  | RelationArray\n  | Array<Value>;\n","import { Block, Schema } from './getSchema';\n\nconst unsorted = ['break', 'comment'];\nconst defaultSortOrder = [\n  'generator',\n  'datasource',\n  'model',\n  'view',\n  'enum',\n  'break',\n  'comment',\n];\n\n/** Sorts the schema parts, in the given order, and alphabetically for parts of the same type. */\nexport const schemaSorter =\n  (\n    schema: Schema,\n    locales?: string | string[],\n    sortOrder: string[] = defaultSortOrder\n  ) =>\n  (a: Block, b: Block): number => {\n    // Preserve the position of comments and line breaks relative to their\n    // position in the file, since when a re-sort happens it wouldn't be\n    // clear whether a comment should affix to the object above or below it.\n    const aUnsorted = unsorted.indexOf(a.type) !== -1;\n    const bUnsorted = unsorted.indexOf(b.type) !== -1;\n\n    if (aUnsorted !== bUnsorted) {\n      return schema.list.indexOf(a) - schema.list.indexOf(b);\n    }\n\n    if (sortOrder !== defaultSortOrder)\n      sortOrder = sortOrder.concat(defaultSortOrder);\n    const typeIndex = sortOrder.indexOf(a.type) - sortOrder.indexOf(b.type);\n    if (typeIndex !== 0) return typeIndex;\n\n    // Resolve ties using the name of object's name.\n    if ('name' in a && 'name' in b)\n      return a.name.localeCompare(b.name, locales);\n\n    // If all else fails, leave objects in their original position.\n    return 0;\n  };\n","import * as Types from './getSchema';\nimport { EOL } from 'os';\nimport { schemaSorter } from './schemaSorter';\n\nexport interface PrintOptions {\n  sort?: boolean;\n  locales?: string | string[];\n  sortOrder?: Array<'generator' | 'datasource' | 'model' | 'view' | 'enum'>;\n}\n\n/**\n * Converts the given schema object into a string representing the prisma\n * schema's source code. Optionally can take options to change the sort order\n * of the schema parts.\n * */\nexport function printSchema(\n  schema: Types.Schema,\n  options: PrintOptions = {}\n): string {\n  const { sort = false, locales = undefined, sortOrder = undefined } = options;\n  let blocks = schema.list;\n  if (sort) {\n    // no point in preserving line breaks when re-sorting\n    blocks = schema.list = blocks.filter((block) => block.type !== 'break');\n    const sorter = schemaSorter(schema, locales, sortOrder);\n    blocks.sort(sorter);\n  }\n\n  return (\n    blocks\n      .map(printBlock)\n      .filter(Boolean)\n      .join(EOL)\n      .replace(/(\\r?\\n\\s*){3,}/g, EOL + EOL) + EOL\n  );\n}\n\nfunction printBlock(block: Types.Block): string {\n  switch (block.type) {\n    case 'comment':\n      return printComment(block);\n    case 'datasource':\n      return printDatasource(block);\n    case 'enum':\n      return printEnum(block);\n    case 'generator':\n      return printGenerator(block);\n    case 'model':\n    case 'view':\n      return printObject(block);\n    case 'break':\n      return printBreak();\n    default:\n      throw new Error(`Unrecognized block type`);\n  }\n}\n\nfunction printComment(comment: Types.Comment) {\n  return comment.text;\n}\n\nfunction printBreak() {\n  return EOL;\n}\n\nfunction printDatasource(db: Types.Datasource) {\n  const children = computeAssignmentFormatting(db.assignments);\n\n  return `\ndatasource ${db.name} {\n  ${children}\n}`;\n}\n\nfunction printEnum(enumerator: Types.Enum) {\n  const children = enumerator.enumerators\n    .map(printEnumerator)\n    .filter(Boolean)\n    .join(`${EOL}  `)\n    .replace(/(\\r?\\n\\s*){3,}/g, `${EOL + EOL}  `);\n\n  return `\nenum ${enumerator.name} {\n  ${children}\n}`;\n}\n\nfunction printEnumerator(\n  enumerator: Types.Enumerator | Types.Attribute | Types.Comment | Types.Break\n) {\n  switch (enumerator.type) {\n    case 'enumerator':\n      return [enumerator.name, enumerator.comment].filter(Boolean).join(' ');\n    case 'attribute':\n      return printAttribute(enumerator);\n    case 'comment':\n      return printComment(enumerator);\n    case 'break':\n      return printBreak();\n    default:\n      throw new Error(`Unexpected enumerator type`);\n  }\n}\n\nfunction printGenerator(generator: Types.Generator) {\n  const children = computeAssignmentFormatting(generator.assignments);\n\n  return `\ngenerator ${generator.name} {\n  ${children}\n}`;\n}\n\nfunction printObject(object: Types.Object) {\n  const children = computePropertyFormatting(object.properties);\n\n  return `\n${object.type} ${object.name} {\n  ${children}\n}`;\n}\n\nfunction printAssignment(\n  node: Types.Assignment | Types.Comment | Types.Break,\n  keyLength = 0\n) {\n  switch (node.type) {\n    case 'comment':\n      return printComment(node);\n    case 'break':\n      return printBreak();\n    case 'assignment':\n      return `${node.key.padEnd(keyLength)} = ${printValue(node.value)}`;\n    default:\n      throw new Error(`Unexpected assignment type`);\n  }\n}\n\nfunction printProperty(\n  node: Types.Property | Types.Comment | Types.Break,\n  nameLength = 0,\n  typeLength = 0\n) {\n  switch (node.type) {\n    case 'attribute':\n      return printAttribute(node);\n    case 'field':\n      return printField(node, nameLength, typeLength);\n    case 'comment':\n      return printComment(node);\n    case 'break':\n      return printBreak();\n    default:\n      throw new Error(`Unrecognized property type`);\n  }\n}\n\nfunction printAttribute(attribute: Types.Attribute | Types.BlockAttribute) {\n  const args =\n    attribute.args && attribute.args.length > 0\n      ? `(${attribute.args.map(printAttributeArg).filter(Boolean).join(', ')})`\n      : '';\n\n  const name = [attribute.name];\n  if (attribute.group) name.unshift(attribute.group);\n\n  return `${attribute.kind === 'field' ? '@' : '@@'}${name.join('.')}${args}`;\n}\n\nfunction printAttributeArg(arg: Types.AttributeArgument) {\n  return printValue(arg.value);\n}\n\nfunction printField(field: Types.Field, nameLength = 0, typeLength = 0) {\n  const name = field.name.padEnd(nameLength);\n  const fieldType = printFieldType(field).padEnd(typeLength);\n  const attrs = field.attributes ? field.attributes.map(printAttribute) : [];\n  const comment = field.comment;\n  return (\n    [name, fieldType, ...attrs]\n      .filter(Boolean)\n      .join(' ')\n      // comments ignore indents\n      .trim() + (comment ? ` ${comment}` : '')\n  );\n}\n\nfunction printFieldType(field: Types.Field) {\n  const suffix = field.array ? '[]' : field.optional ? '?' : '';\n\n  if (typeof field.fieldType === 'object') {\n    switch (field.fieldType.type) {\n      case 'function': {\n        return `${printFunction(field.fieldType)}${suffix}`;\n      }\n      default:\n        throw new Error(`Unexpected field type`);\n    }\n  }\n\n  return `${field.fieldType}${suffix}`;\n}\n\nfunction printFunction(func: Types.Func) {\n  const params = func.params ? func.params.map(printValue) : '';\n  return `${func.name}(${params})`;\n}\n\nfunction printValue(value: Types.KeyValue | Types.Value): string {\n  switch (typeof value) {\n    case 'object': {\n      if ('type' in value) {\n        switch (value.type) {\n          case 'keyValue':\n            return `${value.key}: ${printValue(value.value)}`;\n          case 'function':\n            return printFunction(value);\n          case 'array':\n            return `[${\n              value.args != null ? value.args.map(printValue).join(', ') : ''\n            }]`;\n          default:\n            throw new Error(`Unexpected value type`);\n        }\n      }\n\n      throw new Error(`Unexpected object value`);\n    }\n    default:\n      return String(value);\n  }\n}\n\nfunction computeAssignmentFormatting(\n  list: Array<Types.Comment | Types.Break | Types.Assignment>\n) {\n  let pos = 0;\n  const listBlocks = list.reduce<Array<typeof list>>(\n    (memo, current, index, arr) => {\n      if (current.type === 'break') return memo;\n      if (index > 0 && arr[index - 1].type === 'break') memo[++pos] = [];\n      memo[pos].push(current);\n      return memo;\n    },\n    [[]]\n  );\n\n  const keyLengths = listBlocks.map((lists) =>\n    lists.reduce(\n      (max, current) =>\n        Math.max(\n          max,\n          // perhaps someone more typescript-savy than I am can fix this\n          current.type === 'assignment' ? current.key.length : 0\n        ),\n      0\n    )\n  );\n\n  return list\n    .map((item, index, arr) => {\n      if (index > 0 && item.type !== 'break' && arr[index - 1].type === 'break')\n        keyLengths.shift();\n      return printAssignment(item, keyLengths[0]);\n    })\n    .filter(Boolean)\n    .join(`${EOL}  `)\n    .replace(/(\\r?\\n\\s*){3,}/g, `${EOL + EOL}  `);\n}\n\nfunction computePropertyFormatting(\n  list: Array<Types.Break | Types.Comment | Types.Property>\n) {\n  let pos = 0;\n  const listBlocks = list.reduce<Array<typeof list>>(\n    (memo, current, index, arr) => {\n      if (current.type === 'break') return memo;\n      if (index > 0 && arr[index - 1].type === 'break') memo[++pos] = [];\n      memo[pos].push(current);\n      return memo;\n    },\n    [[]]\n  );\n\n  const nameLengths = listBlocks.map((lists) =>\n    lists.reduce(\n      (max, current) =>\n        Math.max(\n          max,\n          // perhaps someone more typescript-savy than I am can fix this\n          current.type === 'field' ? current.name.length : 0\n        ),\n      0\n    )\n  );\n\n  const typeLengths = listBlocks.map((lists) =>\n    lists.reduce(\n      (max, current) =>\n        Math.max(\n          max,\n          // perhaps someone more typescript-savy than I am can fix this\n          current.type === 'field' ? printFieldType(current).length : 0\n        ),\n      0\n    )\n  );\n\n  return list\n    .map((prop, index, arr) => {\n      if (\n        index > 0 &&\n        prop.type !== 'break' &&\n        arr[index - 1].type === 'break'\n      ) {\n        nameLengths.shift();\n        typeLengths.shift();\n      }\n\n      return printProperty(prop, nameLengths[0], typeLengths[0]);\n    })\n    .filter(Boolean)\n    .join(`${EOL}  `)\n    .replace(/(\\r?\\n\\s*){3,}/g, `${EOL + EOL}  `);\n}\n","import * as schema from './getSchema';\nimport { isSchemaField, isSchemaObject } from './schemaUtils';\nimport { PrintOptions, printSchema } from './printSchema';\n\n/** Returns the function type Original with its return type changed to NewReturn. */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ReplaceReturnType<Original extends (...args: any) => any, NewReturn> = (\n  ...a: Parameters<Original>\n) => NewReturn;\n\n/**\n * Methods with return values that do not propagate the builder should not have\n * their return value modified by the type replacement system below\n * */\ntype ExtractKeys = 'getSchema' | 'getSubject' | 'getParent' | 'print';\n\n/** These keys preserve the return value context that they were given */\ntype NeutralKeys = 'break' | 'comment' | 'attribute' | 'enumerator' | 'then';\n\n/** Keys allowed when you call .datasource() or .generator() */\ntype DatasourceOrGeneratorKeys = 'assignment';\n\n/** Keys allowed when you call .enum(\"name\") */\ntype EnumKeys = 'enumerator';\n\n/** Keys allowed when you call .field(\"name\") */\ntype FieldKeys = 'attribute' | 'removeAttribute';\n\n/** Keys allowed when you call .model(\"name\") */\ntype BlockKeys = 'blockAttribute' | 'field' | 'removeField';\n\n/**\n * Utility type for making the PrismaSchemaBuilder below readable:\n * Removes methods from the builder that are prohibited based on the context\n * the builder is in. For example, you can add fields to a model, but you can't\n * add fields to an enum or a datasource.\n */\ntype PrismaSchemaSubset<\n  Universe extends keyof ConcretePrismaSchemaBuilder,\n  Method\n> = ReplaceReturnType<\n  ConcretePrismaSchemaBuilder[Universe],\n  PrismaSchemaBuilder<Exclude<keyof ConcretePrismaSchemaBuilder, Method>>\n>;\n\n/**\n * The brain of this whole operation: depending on the key of the method name\n * we receive, filter the available list of method calls the user can make to\n * prevent them from making invalid calls, such as builder.datasource().field()\n * */\ntype PrismaSchemaBuilder<K extends keyof ConcretePrismaSchemaBuilder> = {\n  [U in K]: U extends ExtractKeys\n    ? ConcretePrismaSchemaBuilder[U]\n    : U extends NeutralKeys\n    ? ConcretePrismaSchemaBuilder[U] //ReplaceReturnType<ConcretePrismaSchemaBuilder[U], PrismaSchemaBuilder<K>>\n    : U extends 'datasource'\n    ? PrismaSchemaSubset<U, 'datasource' | EnumKeys | FieldKeys | BlockKeys>\n    : U extends 'generator'\n    ? PrismaSchemaSubset<U, EnumKeys | FieldKeys | BlockKeys>\n    : U extends 'model'\n    ? PrismaSchemaSubset<U, DatasourceOrGeneratorKeys | EnumKeys | FieldKeys>\n    : U extends 'view'\n    ? PrismaSchemaSubset<U, DatasourceOrGeneratorKeys | EnumKeys | FieldKeys>\n    : U extends 'field'\n    ? PrismaSchemaSubset<U, DatasourceOrGeneratorKeys | EnumKeys>\n    : U extends 'removeField'\n    ? PrismaSchemaSubset<U, DatasourceOrGeneratorKeys | EnumKeys | FieldKeys>\n    : U extends 'enum'\n    ? PrismaSchemaSubset<U, DatasourceOrGeneratorKeys | BlockKeys | FieldKeys>\n    : U extends 'removeAttribute'\n    ? PrismaSchemaSubset<U, DatasourceOrGeneratorKeys | EnumKeys>\n    : PrismaSchemaSubset<\n        U,\n        DatasourceOrGeneratorKeys | EnumKeys | FieldKeys | BlockKeys | 'comment'\n      >;\n};\n\ntype Arg =\n  | string\n  | {\n      name: string;\n      function?: Arg[];\n    };\ntype Parent = schema.Block | undefined;\ntype Subject = schema.Block | schema.Field | undefined;\n\nexport class ConcretePrismaSchemaBuilder {\n  private schema: schema.Schema;\n  private _subject: Subject;\n  private _parent: Parent;\n\n  constructor(source = '') {\n    this.schema = schema.getSchema(source);\n  }\n\n  /** Prints the schema out as a source string */\n  print(options: PrintOptions = {}): string {\n    return printSchema(this.schema, options);\n  }\n\n  /** Returns the underlying schema object for more advanced use cases. */\n  getSchema(): schema.Schema {\n    return this.schema;\n  }\n\n  /** Adds or updates a generator block based on the name. */\n  generator(name: string, provider = 'prisma-client-js'): this {\n    const generator: schema.Generator =\n      this.schema.list.reduce<schema.Generator>(\n        (memo, block) =>\n          block.type === 'generator' && block.name === name ? block : memo,\n        {\n          type: 'generator',\n          name,\n          assignments: [\n            { type: 'assignment', key: 'provider', value: `\"${provider}\"` },\n          ],\n        }\n      );\n\n    if (!this.schema.list.includes(generator)) this.schema.list.push(generator);\n    this._subject = generator;\n    return this;\n  }\n\n  /** Removes something from the schema with the given name. */\n  drop(name: string): this {\n    const index = this.schema.list.findIndex(\n      (block) => 'name' in block && block.name === name\n    );\n    if (index !== -1) this.schema.list.splice(index, 1);\n    return this;\n  }\n\n  /** Sets the datasource for the schema. */\n  datasource(provider: string, url: string | { env: string }): this {\n    const datasource: schema.Datasource = {\n      type: 'datasource',\n      name: 'db',\n      assignments: [\n        {\n          type: 'assignment',\n          key: 'url',\n          value:\n            typeof url === 'string'\n              ? `\"${url}\"`\n              : { type: 'function', name: 'env', params: [`\"${url.env}\"`] },\n        },\n        { type: 'assignment', key: 'provider', value: provider },\n      ],\n    };\n    const existingIndex = this.schema.list.findIndex(\n      (block) => block.type === 'datasource'\n    );\n    this.schema.list.splice(\n      existingIndex,\n      existingIndex !== -1 ? 1 : 0,\n      datasource\n    );\n    this._subject = datasource;\n    return this;\n  }\n\n  /** Adds or updates a model based on the name. Can be chained with .field() or .blockAttribute() to add to it. */\n  model(name: string): this {\n    const model = this.schema.list.reduce<schema.Model>(\n      (memo, block) =>\n        block.type === 'model' && block.name === name ? block : memo,\n      { type: 'model', name, properties: [] }\n    );\n    if (!this.schema.list.includes(model)) this.schema.list.push(model);\n    this._subject = model;\n    return this;\n  }\n\n  /** Adds or updates a view based on the name. Can be chained with .field() or .blockAttribute() to add to it. */\n  view(name: string): this {\n    const view = this.schema.list.reduce<schema.View>(\n      (memo, block) =>\n        block.type === 'view' && block.name === name ? block : memo,\n      { type: 'view', name, properties: [] }\n    );\n    if (!this.schema.list.includes(view)) this.schema.list.push(view);\n    this._subject = view;\n    return this;\n  }\n\n  /** Adds or updates an enum based on the name. Can be chained with .enumerator() to add a value to it. */\n  enum(name: string, enumeratorNames: string[] = []): this {\n    const e = this.schema.list.reduce<schema.Enum>(\n      (memo, block) =>\n        block.type === 'enum' && block.name === name ? block : memo,\n      {\n        type: 'enum',\n        name,\n        enumerators: enumeratorNames.map((name) => ({\n          type: 'enumerator',\n          name,\n        })),\n      }\n    );\n    if (!this.schema.list.includes(e)) this.schema.list.push(e);\n    this._subject = e;\n    return this;\n  }\n\n  /** Add an enum value to the current enum. */\n  enumerator(value: string): this {\n    const subject = this.getSubject<schema.Enum>();\n    if (!subject || !('type' in subject) || subject.type !== 'enum') {\n      throw new Error('Subject must be a prisma enum!');\n    }\n\n    subject.enumerators.push({ type: 'enumerator', name: value });\n    return this;\n  }\n\n  /**\n   * Returns the current subject, such as a model, field, or enum.\n   * @example\n   * builder.getModel('User').field('firstName').getSubject() // the firstName field\n   * */\n  private getSubject<S extends Subject>(): S {\n    return this._subject as S;\n  }\n\n  /** Returns the parent of the current subject when in a nested context. The parent of a field is its model or view. */\n  private getParent<S extends Parent = schema.Object>(): S {\n    return this._parent as S;\n  }\n\n  /**\n   * Adds a block-level attribute to the current model.\n   * @example\n   * builder.model('Project')\n   *   .blockAttribute(\"map\", \"projects\")\n   *   .blockAttribute(\"unique\", [\"firstName\", \"lastName\"]) // @@unique([firstName, lastName])\n   * */\n  blockAttribute(\n    name: string,\n    args?: string | string[] | Record<string, schema.Value>\n  ): this {\n    let subject = this.getSubject<schema.Object>();\n    if (!isSchemaObject(subject)) {\n      const parent = this.getParent<schema.Object>();\n      if (!isSchemaObject(parent))\n        throw new Error('Subject must be a prisma model or view!');\n\n      subject = this._subject = parent;\n    }\n\n    const attributeArgs = ((): schema.AttributeArgument[] => {\n      if (!args) return [] as schema.AttributeArgument[];\n      if (typeof args === 'string')\n        return [{ type: 'attributeArgument', value: `\"${args}\"` }];\n      if (Array.isArray(args))\n        return [{ type: 'attributeArgument', value: { type: 'array', args } }];\n      return Object.entries(args).map(([key, value]) => ({\n        type: 'attributeArgument',\n        value: { type: 'keyValue', key, value },\n      }));\n    })();\n\n    const property: schema.BlockAttribute = {\n      type: 'attribute',\n      kind: 'object',\n      name,\n      args: attributeArgs,\n    };\n    subject.properties.push(property);\n    return this;\n  }\n\n  /** Adds an attribute to the current field. */\n  attribute<T extends schema.Field>(\n    name: string,\n    args?: Arg[] | Record<string, string[]>\n  ): this {\n    const parent = this.getParent();\n    const subject = this.getSubject<T>();\n    if (!isSchemaObject(parent)) {\n      throw new Error('Parent must be a prisma model or view!');\n    }\n\n    if (!isSchemaField(subject)) {\n      throw new Error('Subject must be a prisma field!');\n    }\n\n    if (!subject.attributes) subject.attributes = [];\n    const attribute = subject.attributes.reduce<schema.Attribute>(\n      (memo, attr) =>\n        attr.type === 'attribute' &&\n        `${attr.group ? `${attr.group}.` : ''}${attr.name}` === name\n          ? attr\n          : memo,\n      {\n        type: 'attribute',\n        kind: 'field',\n        name,\n      }\n    );\n\n    if (Array.isArray(args)) {\n      const mapArg = (arg: Arg): schema.Value | schema.Func => {\n        return typeof arg === 'string'\n          ? arg\n          : {\n              type: 'function',\n              name: arg.name,\n              params: arg.function?.map(mapArg) ?? [],\n            };\n      };\n\n      if (args.length > 0)\n        attribute.args = args.map((arg) => ({\n          type: 'attributeArgument',\n          value: mapArg(arg),\n        }));\n    } else if (typeof args === 'object') {\n      attribute.args = Object.entries(args).map(([key, value]) => ({\n        type: 'attributeArgument',\n        value: { type: 'keyValue', key, value: { type: 'array', args: value } },\n      }));\n    }\n\n    if (!subject.attributes.includes(attribute))\n      subject.attributes.push(attribute);\n\n    return this;\n  }\n\n  /** Remove an attribute from the current field */\n  removeAttribute<T extends schema.Field>(name: string): this {\n    const parent = this.getParent();\n    const subject = this.getSubject<T>();\n    if (!isSchemaObject(parent)) {\n      throw new Error('Parent must be a prisma model or view!');\n    }\n\n    if (!isSchemaField(subject)) {\n      throw new Error('Subject must be a prisma field!');\n    }\n\n    if (!subject.attributes) subject.attributes = [];\n    subject.attributes = subject.attributes.filter(\n      (attr) => !(attr.type === 'attribute' && attr.name === name)\n    );\n\n    return this;\n  }\n\n  /** Add an assignment to a generator or datasource */\n  assignment<T extends schema.Generator | schema.Datasource>(\n    key: string,\n    value: string\n  ): this {\n    const subject = this.getSubject<T>();\n    if (\n      !subject ||\n      !('type' in subject) ||\n      !['generator', 'datasource'].includes(subject.type)\n    )\n      throw new Error('Subject must be a prisma generator or datasource!');\n\n    function tap<T>(subject: T, callback: (s: T) => void) {\n      callback(subject);\n      return subject;\n    }\n\n    const assignment = subject.assignments.reduce<schema.Assignment>(\n      (memo, assignment) =>\n        assignment.type === 'assignment' && assignment.key === key\n          ? tap(assignment, (a) => {\n              a.value = `\"${value}\"`;\n            })\n          : memo,\n      {\n        type: 'assignment',\n        key,\n        value: `\"${value}\"`,\n      }\n    );\n\n    if (!subject.assignments.includes(assignment))\n      subject.assignments.push(assignment);\n\n    return this;\n  }\n\n  private blockInsert(statement: schema.Break | schema.Comment): this {\n    let subject = this.getSubject<schema.Block>();\n    const allowed = ['datasource', 'enum', 'generator', 'model', 'view'];\n    if (!subject || !('type' in subject) || !allowed.includes(subject.type)) {\n      const parent = this.getParent<schema.Block>();\n      if (!parent || !('type' in parent) || !allowed.includes(parent.type)) {\n        throw new Error('Subject must be a prisma block!');\n      }\n\n      subject = this._subject = parent;\n    }\n\n    switch (subject.type) {\n      case 'datasource': {\n        subject.assignments.push(statement);\n        break;\n      }\n      case 'enum': {\n        subject.enumerators.push(statement);\n        break;\n      }\n      case 'generator': {\n        subject.assignments.push(statement);\n        break;\n      }\n      case 'model': {\n        subject.properties.push(statement);\n        break;\n      }\n    }\n    return this;\n  }\n\n  /** Add a line break */\n  break(): this {\n    const lineBreak: schema.Break = { type: 'break' };\n    return this.blockInsert(lineBreak);\n  }\n\n  /**\n   * Add a comment. Regular comments start with // and do not appear in the\n   * prisma AST. Node comments start with /// and will appear in the AST,\n   * affixed to the node that follows the comment.\n   * */\n  comment(text: string, node = false): this {\n    const comment: schema.Comment = {\n      type: 'comment',\n      text: `//${node ? '/' : ''} ${text}`,\n    };\n    return this.blockInsert(comment);\n  }\n\n  /**\n   * Add a comment to the schema. Regular comments start with // and do not appear in the\n   * prisma AST. Node comments start with /// and will appear in the AST,\n   * affixed to the node that follows the comment.\n   * */\n  schemaComment(text: string, node = false): this {\n    const comment: schema.Comment = {\n      type: 'comment',\n      text: `//${node ? '/' : ''} ${text}`,\n    };\n    this.schema.list.push(comment);\n    return this;\n  }\n\n  /**\n   * Adds or updates a field in the current model. The field can be customized\n   * further with one or more .attribute() calls.\n   * */\n  field(name: string, fieldType: string | schema.Func = 'String'): this {\n    let subject = this.getSubject<schema.Object>();\n    if (!isSchemaObject(subject)) {\n      const parent = this.getParent<schema.Object>();\n      if (!isSchemaObject(parent))\n        throw new Error('Subject must be a prisma model or view!');\n\n      subject = this._subject = parent;\n    }\n\n    const field = subject.properties.reduce<schema.Field>(\n      (memo, block) =>\n        block.type === 'field' && block.name === name ? block : memo,\n      {\n        type: 'field',\n        name,\n        fieldType,\n      }\n    );\n\n    if (!subject.properties.includes(field)) subject.properties.push(field);\n    this._parent = subject;\n    this._subject = field;\n    return this;\n  }\n\n  /** Drop a field from the current model or view. */\n  removeField(name: string): this {\n    let subject = this.getSubject<schema.Object>();\n    if (!isSchemaObject(subject)) {\n      const parent = this.getParent<schema.Object>();\n      if (!isSchemaObject(parent))\n        throw new Error('Subject must be a prisma model or view!');\n\n      subject = this._subject = parent;\n    }\n\n    subject.properties = subject.properties.filter(\n      (field) => !(field.type === 'field' && field.name === name)\n    );\n    return this;\n  }\n\n  /**\n   * Returns the current subject, allowing for more advanced ways of\n   * manipulating the schema.\n   * */\n  then<R extends NonNullable<Subject>>(\n    callback: (subject: R) => unknown\n  ): this {\n    callback(this._subject as R);\n    return this;\n  }\n}\n\nexport function createPrismaSchemaBuilder(\n  source?: string\n): PrismaSchemaBuilder<\n  Exclude<\n    keyof ConcretePrismaSchemaBuilder,\n    DatasourceOrGeneratorKeys | EnumKeys | FieldKeys | BlockKeys\n  >\n> {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return new ConcretePrismaSchemaBuilder(source) as any;\n}\n"],"names":["Identifier","createToken","name","pattern","Datasource","push_mode","Generator","Model","View","Enum","True","longer_alt","False","Null","Comment","Lexer","NA","DocComment","categories","LineComment","Attribute","BlockAttribute","label","FieldAttribute","Dot","QuestionMark","LCurly","RCurly","pop_mode","LRound","RRound","LSquare","RSquare","Comma","Colon","Equals","StringLiteral","NumberLiteral","WhiteSpace","group","SKIPPED","LineBreak","line_breaks","naTokens","multiModeTokens","modes","global","concat","block","defaultMode","PrismaLexer","config","defaultConfig","parser","nodeLocationTracking","getConfig","result","configSync","lilconfigSync","search","Object","assign","PrismaParser","_CstParser","_this","call","lexer","this","RULE","CONSUME1","CONSUME2","keyedArg","CONSUME","LABEL","SUBRULE","value","array","MANY_SEP","SEP","DEF","func","OR","ALT","property","assignment","field","OPTION1","MANY","attribute","OPTION2","options","componentType","isEnum","isObject","comment","GATE","OPTION","OR1","OR2","attributeArg","component","type","ARGS","image","schema","performSelfAnalysis","_inheritsLoose","CstParser","schemaObjects","isSchemaObject","obj","includes","isSchemaField","appendLocationData","data","_len","arguments","length","tokens","Array","_key","location","reduce","memo","token","_memo$endColumn","endColumn","Infinity","_memo$endLine","endLine","_memo$endOffset","endOffset","_memo$startColumn","startColumn","_memo$startLine","startLine","_memo$startOffset","startOffset","PrismaVisitor","_BasePrismaVisitor","validateVisitor","_proto","prototype","ctx","_ctx$list","_this2","list","map","item","visit","componentName","assignments","properties","enumerators","Error","text","_ctx$list2","_this3","assignmentValue","key","assignmentName","_ctx$comment","_ctx$optional","_ctx$array","_this4","fieldType","fieldName","attributes","attributeList","optional","_this5","attributeName","groupName","args","attr","kind","blockAttribute","apply","fieldAttribute","_this6","funcName","params","keyedParams","pars","_this7","keyName","_ctx$comment2","enumName","getBaseCstVisitorConstructorWithDefaults","getSchema","source","lexingResult","tokenize","input","cstNode","errors","unsorted","defaultSortOrder","printSchema","_options$sort","sort","_options$locales","locales","undefined","_options$sortOrder","sortOrder","blocks","filter","sorter","a","b","indexOf","typeIndex","localeCompare","schemaSorter","printBlock","Boolean","join","EOL","replace","printComment","children","computeAssignmentFormatting","db","enumerator","printEnumerator","printEnum","generator","printGenerator","object","pos","listBlocks","nameLengths","typeLengths","current","index","arr","push","lists","max","Math","printFieldType","prop","shift","node","nameLength","typeLength","printAttribute","padEnd","attrs","trim","printField","printBreak","printProperty","printObject","printAttributeArg","unshift","arg","printValue","suffix","printFunction","String","keyLengths","keyLength","printAssignment","ConcretePrismaSchemaBuilder","_subject","_parent","print","provider","drop","findIndex","splice","datasource","url","env","existingIndex","model","view","enumeratorNames","e","subject","getSubject","getParent","parent","attributeArgs","isArray","entries","_ref","mapArg","_arg$function$map","_arg$function","_ref2","removeAttribute","callback","tap","blockInsert","statement","allowed","schemaComment","removeField","then"],"mappings":"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"}