{"version":3,"file":"index.umd.js","sources":["../src/internals/symbols.ts","../src/internals/helpers.ts","../src/patterns.ts","../src/match.ts","../src/is-matching.ts"],"sourcesContent":["/**\n * Symbols used internally within ts-pattern to construct and discriminate\n * Guard, Not, and Select, and AnonymousSelect patterns\n *\n * Symbols have the advantage of not appearing in auto-complete suggestions in\n * user defined patterns, and eliminate the risk of property\n * overlap between ts-pattern internals and user defined patterns.\n *\n * These symbols have to be visible to tsc for type inference to work, but\n * users should not import them\n * @module\n * @private\n * @internal\n */\n\nexport const toExclude = Symbol('@ts-pattern/to-exclude');\nexport type toExclude = typeof toExclude;\n\nexport const matcher = Symbol('@ts-pattern/matcher');\nexport type matcher = typeof matcher;\n\nexport const unset = Symbol('@ts-pattern/unset');\nexport type unset = typeof unset;\n\nexport const anonymousSelectKey = '@ts-pattern/anonymous-select-key';\nexport type anonymousSelectKey = typeof anonymousSelectKey;\n","/**\n * @module\n * @private\n * @internal\n */\n\nimport * as symbols from './symbols';\nimport { SelectionType } from '../types/FindSelected';\nimport { Pattern, Matcher, MatcherType } from '../types/Pattern';\n\n// @internal\nexport const isObject = (value: unknown): value is Object =>\n  Boolean(value && typeof value === 'object');\n\n//   @internal\nexport const isMatcher = (\n  x: unknown\n): x is Matcher<unknown, unknown, MatcherType, SelectionType> => {\n  const pattern = x as Matcher<unknown, unknown, MatcherType, SelectionType>;\n  return pattern && !!pattern[symbols.matcher];\n};\n\n// @internal\nconst isOptionalPattern = (\n  x: unknown\n): x is Matcher<unknown, unknown, 'optional', SelectionType> => {\n  return isMatcher(x) && x[symbols.matcher]().matcherType === 'optional';\n};\n\n// tells us if the value matches a given pattern.\n// @internal\nexport const matchPattern = (\n  pattern: Pattern<any>,\n  value: any,\n  select: (key: string, value: unknown) => void\n): boolean => {\n  if (isObject(pattern)) {\n    if (isMatcher(pattern)) {\n      const matcher = pattern[symbols.matcher]();\n      const { matched, selections } = matcher.match(value);\n      if (matched && selections) {\n        Object.keys(selections).forEach((key) => select(key, selections[key]));\n      }\n      return matched;\n    }\n\n    if (!isObject(value)) return false;\n\n    if (Array.isArray(pattern)) {\n      if (!Array.isArray(value)) return false;\n      // Tuple pattern\n      return pattern.length === value.length\n        ? pattern.every((subPattern, i) =>\n            matchPattern(subPattern, value[i], select)\n          )\n        : false;\n    }\n\n    if (pattern instanceof Map) {\n      if (!(value instanceof Map)) return false;\n      return Array.from(pattern.keys()).every((key) =>\n        matchPattern(pattern.get(key), value.get(key), select)\n      );\n    }\n\n    if (pattern instanceof Set) {\n      if (!(value instanceof Set)) return false;\n\n      if (pattern.size === 0) return value.size === 0;\n\n      if (pattern.size === 1) {\n        const [subPattern] = Array.from(pattern.values());\n        return isMatcher(subPattern)\n          ? Array.from(value.values()).every((v) =>\n              matchPattern(subPattern, v, select)\n            )\n          : value.has(subPattern);\n      }\n\n      return Array.from(pattern.values()).every((subPattern) =>\n        value.has(subPattern)\n      );\n    }\n\n    return Object.keys(pattern).every((k: string): boolean => {\n      // @ts-ignore\n      const subPattern = pattern[k];\n\n      return (\n        (k in value || isOptionalPattern(subPattern)) &&\n        matchPattern(\n          subPattern,\n          // @ts-ignore\n          value[k],\n          select\n        )\n      );\n    });\n  }\n\n  return Object.is(value, pattern);\n};\n\n// @internal\nexport const getSelectionKeys = (pattern: Pattern<any>): string[] => {\n  if (isObject(pattern)) {\n    if (isMatcher(pattern)) {\n      return pattern[symbols.matcher]().getSelectionKeys?.() ?? [];\n    }\n    if (Array.isArray(pattern)) return flatMap(pattern, getSelectionKeys);\n    return flatMap(Object.values(pattern), getSelectionKeys);\n  }\n  return [];\n};\n\n// @internal\nexport const flatMap = <a, b>(xs: a[], f: (v: a) => b[]): b[] =>\n  xs.reduce<b[]>((acc, p) => acc.concat(f(p)), []);\n","import { matchPattern, getSelectionKeys, flatMap } from './internals/helpers';\nimport * as symbols from './internals/symbols';\nimport { GuardFunction, IsNever, Primitives } from './types/helpers';\nimport { InvertPattern } from './types/InvertPattern';\nimport {\n  Pattern,\n  UnknownPattern,\n  OptionalP,\n  ArrayP,\n  AndP,\n  OrP,\n  NotP,\n  GuardP,\n  SelectP,\n  AnonymousSelectP,\n  GuardExcludeP,\n} from './types/Pattern';\n\nexport { Pattern };\n\n/**\n * `P.infer<typeof somePattern>` will return the type of the value\n * matched by this pattern.\n *\n * [Read documentation for `P.infer` on GitHub](https://github.com/gvergnaud/ts-pattern#Pinfer)\n *\n * @example\n * const userPattern = { name: P.string }\n * type User = P.infer<typeof userPattern>\n */\nexport type infer<p extends Pattern<any>> = InvertPattern<p>;\n\n/**\n * `P.optional(subpattern)` takes a sub pattern and returns a pattern which matches if the\n * key is undefined or if it is defined and the sub pattern matches its value.\n *\n * [Read documentation for `P.optional` on GitHub](https://github.com/gvergnaud/ts-pattern#Poptional-patterns)\n\n* @example\n *  match(value)\n *   .with({ greeting: P.optional('Hello') }, () => 'will match { greeting?: \"Hello\" }')\n */\nexport function optional<\n  input,\n  p extends unknown extends input ? UnknownPattern : Pattern<input>\n>(pattern: p): OptionalP<input, p> {\n  return {\n    [symbols.matcher]() {\n      return {\n        match: <I>(value: I | input) => {\n          let selections: Record<string, unknown[]> = {};\n          const selector = (key: string, value: any) => {\n            selections[key] = value;\n          };\n          if (value === undefined) {\n            getSelectionKeys(pattern).forEach((key) =>\n              selector(key, undefined)\n            );\n            return { matched: true, selections };\n          }\n          const matched = matchPattern(pattern, value, selector);\n          return { matched, selections };\n        },\n        getSelectionKeys: () => getSelectionKeys(pattern),\n        matcherType: 'optional',\n      };\n    },\n  };\n}\n\ntype Elem<xs> = xs extends readonly (infer x)[] ? x : never;\n\n/**\n * `P.array(subpattern)` takes a sub pattern and returns a pattern, which matches\n * arrays if all their elements match the sub pattern.\n *\n * [Read documentation for `P.array` on GitHub](https://github.com/gvergnaud/ts-pattern#Parray-patterns)\n *\n * @example\n *  match(value)\n *   .with({ users: P.array({ name: P.string }) }, () => 'will match { name: string }[]')\n */\nexport function array<\n  input,\n  p extends unknown extends input ? UnknownPattern : Pattern<Elem<input>>\n>(pattern: p): ArrayP<input, p> {\n  return {\n    [symbols.matcher]() {\n      return {\n        match: <I>(value: I | input) => {\n          if (!Array.isArray(value)) return { matched: false };\n\n          let selections: Record<string, unknown[]> = {};\n\n          if (value.length === 0) {\n            getSelectionKeys(pattern).forEach((key) => {\n              selections[key] = [];\n            });\n            return { matched: true, selections };\n          }\n\n          const selector = (key: string, value: unknown) => {\n            selections[key] = (selections[key] || []).concat([value]);\n          };\n\n          const matched = value.every((v) =>\n            matchPattern(pattern, v, selector)\n          );\n\n          return { matched, selections };\n        },\n        getSelectionKeys: () => getSelectionKeys(pattern),\n      };\n    },\n  };\n}\n\n/**\n * `P.intersection(...patterns)` returns a pattern which matches\n * only if **every** patterns provided in parameter match the input.\n *\n * [Read documentation for `P.intersection` on GitHub](https://github.com/gvergnaud/ts-pattern#Pintersection-patterns)\n *\n * @example\n *  match(value)\n *   .with(\n *     {\n *       user: P.intersection(\n *         { firstname: P.string },\n *         { lastname: P.string },\n *         { age: P.when(age => age > 21) }\n *       )\n *     },\n *     ({ user }) => 'will match { firstname: string, lastname: string, age: number } if age > 21'\n *   )\n */\nexport function intersection<\n  input,\n  ps extends unknown extends input\n    ? [UnknownPattern, ...UnknownPattern[]]\n    : [Pattern<input>, ...Pattern<input>[]]\n>(...patterns: ps): AndP<input, ps> {\n  return {\n    [symbols.matcher]: () => ({\n      match: (value) => {\n        let selections: Record<string, unknown[]> = {};\n        const selector = (key: string, value: any) => {\n          selections[key] = value;\n        };\n        const matched = (patterns as UnknownPattern[]).every((p) =>\n          matchPattern(p, value, selector)\n        );\n        return { matched, selections };\n      },\n      getSelectionKeys: () =>\n        flatMap(patterns as UnknownPattern[], getSelectionKeys),\n      matcherType: 'and',\n    }),\n  };\n}\n\n/**\n * `P.union(...patterns)` returns a pattern which matches\n * if **at least one** of the patterns provided in parameter match the input.\n *\n * [Read documentation for `P.union` on GitHub](https://github.com/gvergnaud/ts-pattern#Punion-patterns)\n *\n * @example\n *  match(value)\n *   .with(\n *     { type: P.union('a', 'b', 'c') },\n *     ({ user }) => 'will match { type: \"a\" | \"b\" | \"c\" }'\n *   )\n */\nexport function union<\n  input,\n  ps extends unknown extends input\n    ? [UnknownPattern, ...UnknownPattern[]]\n    : [Pattern<input>, ...Pattern<input>[]]\n>(...patterns: ps): OrP<input, ps> {\n  return {\n    [symbols.matcher]: () => ({\n      match: <I>(value: I | input) => {\n        let selections: Record<string, unknown[]> = {};\n        const selector = (key: string, value: any) => {\n          selections[key] = value;\n        };\n        flatMap(patterns as UnknownPattern[], getSelectionKeys).forEach((key) =>\n          selector(key, undefined)\n        );\n        const matched = (patterns as UnknownPattern[]).some((p) =>\n          matchPattern(p, value, selector)\n        );\n        return { matched, selections };\n      },\n      getSelectionKeys: () =>\n        flatMap(patterns as UnknownPattern[], getSelectionKeys),\n      matcherType: 'or',\n    }),\n  };\n}\n\n/**\n * `P.not(pattern)` returns a pattern which matches if the sub pattern\n * doesn't match.\n *\n * [Read documentation for `P.not` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnot-patterns)\n *\n * @example\n *  match<{ a: string | number }>(value)\n *   .with({ a: P.not(P.string) }, (x) => 'will match { a: number }'\n *   )\n */\nexport function not<input, p extends Pattern<input> | Primitives>(\n  pattern: p\n): NotP<input, p> {\n  return {\n    [symbols.matcher]: () => ({\n      match: <I>(value: I | input) => ({\n        matched: !matchPattern(pattern, value, () => {}),\n      }),\n      getSelectionKeys: () => [],\n      matcherType: 'not',\n    }),\n  };\n}\n\n/**\n * `P.when((value) => boolean)` returns a pattern which matches\n * if the predicate returns true for the current input.\n *\n * [Read documentation for `P.when` on GitHub](https://github.com/gvergnaud/ts-pattern#Pwhen-patterns)\n *\n * @example\n *  match<{ age: number }>(value)\n *   .with({ age: P.when(age => age > 21) }, (x) => 'will match if value.age > 21'\n *   )\n */\nexport function when<input, p extends (value: input) => unknown>(\n  predicate: p\n): GuardP<\n  input,\n  p extends (value: any) => value is infer narrowed ? narrowed : never\n>;\nexport function when<input, narrowed extends input, excluded>(\n  predicate: (input: input) => input is narrowed\n): GuardExcludeP<input, narrowed, excluded>;\nexport function when<input, p extends (value: input) => unknown>(\n  predicate: p\n): GuardP<\n  input,\n  p extends (value: any) => value is infer narrowed ? narrowed : never\n> {\n  return {\n    [symbols.matcher]: () => ({\n      match: <I>(value: I | input) => ({\n        matched: Boolean(predicate(value as input)),\n      }),\n    }),\n  };\n}\n\n/**\n * `P.select()` is a pattern which will always match,\n * and will inject the selected piece of input in the handler function.\n *\n * [Read documentation for `P.select` on GitHub](https://github.com/gvergnaud/ts-pattern#Pselect-patterns)\n *\n * @example\n *  match<{ age: number }>(value)\n *   .with({ age: P.select() }, (age) => 'age: number'\n *   )\n */\nexport function select(): AnonymousSelectP;\nexport function select<\n  input,\n  patternOrKey extends\n    | string\n    | (unknown extends input ? UnknownPattern : Pattern<input>)\n>(\n  patternOrKey: patternOrKey\n): patternOrKey extends string\n  ? SelectP<patternOrKey>\n  : SelectP<symbols.anonymousSelectKey, input, patternOrKey>;\nexport function select<\n  input,\n  p extends unknown extends input ? UnknownPattern : Pattern<input>,\n  k extends string\n>(key: k, pattern: p): SelectP<k, input, p>;\nexport function select(\n  ...args: [keyOrPattern?: unknown | string, pattern?: unknown]\n): SelectP<string> {\n  const key: string | undefined =\n    typeof args[0] === 'string' ? args[0] : undefined;\n  const pattern: unknown =\n    args.length === 2\n      ? args[1]\n      : typeof args[0] === 'string'\n      ? undefined\n      : args[0];\n  return {\n    [symbols.matcher]() {\n      return {\n        match: (value) => {\n          let selections: Record<string, unknown> = {\n            [key ?? symbols.anonymousSelectKey]: value,\n          };\n          const selector = (key: string, value: any) => {\n            selections[key] = value;\n          };\n          return {\n            matched:\n              pattern === undefined\n                ? true\n                : matchPattern(pattern, value, selector),\n            selections: selections,\n          };\n        },\n        getSelectionKeys: () =>\n          [key ?? symbols.anonymousSelectKey].concat(\n            pattern === undefined ? [] : getSelectionKeys(pattern)\n          ),\n      };\n    },\n  };\n}\n\nfunction isUnknown(x: unknown): x is unknown {\n  return true;\n}\n\nfunction isNumber<T>(x: T | number): x is number {\n  return typeof x === 'number';\n}\n\nfunction isString<T>(x: T | string): x is string {\n  return typeof x === 'string';\n}\n\nfunction isBoolean<T>(x: T | boolean): x is boolean {\n  return typeof x === 'boolean';\n}\n\nfunction isBigInt<T>(x: T | bigint): x is bigint {\n  return typeof x === 'bigint';\n}\n\nfunction isSymbol<T>(x: T | symbol): x is symbol {\n  return typeof x === 'symbol';\n}\n\nfunction isNullish<T>(x: T | null | undefined): x is null | undefined {\n  return x === null || x === undefined;\n}\n\ntype AnyConstructor = abstract new (...args: any[]) => any;\n\nfunction isInstanceOf<T extends AnyConstructor>(classConstructor: T) {\n  return (val: unknown): val is InstanceType<T> =>\n    val instanceof classConstructor;\n}\n\n/**\n * `P.any` is a wildcard pattern, matching **any value**.\n *\n * [Read documentation for `P.any` on GitHub](https://github.com/gvergnaud/ts-pattern#P_-wildcard)\n *\n * @example\n *  match(value)\n *   .with(P.any, () => 'will always match')\n */\nexport const any = when(isUnknown);\n\n/**\n * `P._` is a wildcard pattern, matching **any value**.\n * It's an alias to `P.any`.\n *\n * [Read documentation for `P._` on GitHub](https://github.com/gvergnaud/ts-pattern#P_-wildcard)\n *\n * @example\n *  match(value)\n *   .with(P._, () => 'will always match')\n */\nexport const _ = any;\n\n/**\n * `P.string` is a wildcard pattern matching any **string**.\n *\n * [Read documentation for `P.string` on GitHub](https://github.com/gvergnaud/ts-pattern#Pstring-wildcard)\n *\n * @example\n *  match(value)\n *   .with(P.string, () => 'will match on strings')\n */\n\nexport const string = when(isString);\n\n/**\n * `P.number` is a wildcard pattern matching any **number**.\n *\n * [Read documentation for `P.number` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumber-wildcard)\n *\n * @example\n *  match(value)\n *   .with(P.number, () => 'will match on numbers')\n */\nexport const number = when(isNumber);\n\n/**\n * `P.boolean` is a wildcard pattern matching any **boolean**.\n *\n * [Read documentation for `P.boolean` on GitHub](https://github.com/gvergnaud/ts-pattern#boolean-wildcard)\n *\n * @example\n *   .with(P.boolean, () => 'will match on booleans')\n */\nexport const boolean = when(isBoolean);\n\n/**\n * `P.bigint` is a wildcard pattern matching any **bigint**.\n *\n * [Read documentation for `P.bigint` on GitHub](https://github.com/gvergnaud/ts-pattern#bigint-wildcard)\n *\n * @example\n *   .with(P.bigint, () => 'will match on bigints')\n */\nexport const bigint = when(isBigInt);\n\n/**\n * `P.symbol` is a wildcard pattern matching any **symbol**.\n *\n * [Read documentation for `P.symbol` on GitHub](https://github.com/gvergnaud/ts-pattern#symbol-wildcard)\n *\n * @example\n *   .with(P.symbol, () => 'will match on symbols')\n */\nexport const symbol = when(isSymbol);\n\n/**\n * `P.nullish` is a wildcard pattern matching **null** or **undefined**.\n *\n * [Read documentation for `P.nullish` on GitHub](https://github.com/gvergnaud/ts-pattern#nullish-wildcard)\n *\n * @example\n *   .with(P.nullish, () => 'will match on null or undefined')\n */\nexport const nullish = when(isNullish);\n\n/**\n * `P.instanceOf(SomeClass)` is a pattern matching instances of a given class.\n *\n * [Read documentation for `P.instanceOf` on GitHub](https://github.com/gvergnaud/ts-pattern#Pinstanceof-patterns)\n *\n *  @example\n *   .with(P.instanceOf(SomeClass), () => 'will match on SomeClass instances')\n */\nexport function instanceOf<T extends AnyConstructor>(\n  classConstructor: T\n): GuardP<unknown, InstanceType<T>> {\n  return when(isInstanceOf(classConstructor));\n}\n\n/**\n * `P.typed<SomeType>()` is a way to set the input type this\n * pattern should match on.\n *\n * It returns all utility functions to create patterns,\n * Like `array`, `union`, `intersection`, etc.\n *\n * [Read documentation for `P.typed` on GitHub](https://github.com/gvergnaud/ts-pattern#Ptyped)\n *\n * @example\n *  .with(\n *    P.typed<string | number[]>().array(P.string),\n *    (arrayOfString) => arrayOfString.join(', ')\n *  )\n */\nexport function typed<input>(): {\n  array<p extends Pattern<Elem<input>>>(pattern: p): ArrayP<input, p>;\n\n  optional<p extends Pattern<input>>(pattern: p): OptionalP<input, p>;\n\n  intersection<ps extends [Pattern<input>, ...Pattern<input>[]]>(\n    ...patterns: ps\n  ): AndP<input, ps>;\n\n  union<ps extends [Pattern<input>, ...Pattern<input>[]]>(\n    ...patterns: ps\n  ): OrP<input, ps>;\n\n  not<p extends Pattern<input>>(pattern: p): NotP<input, p>;\n\n  when<narrowed extends input = never>(\n    predicate: GuardFunction<input, narrowed>\n  ): GuardP<input, narrowed>;\n\n  select<pattern extends Pattern<input>>(\n    pattern: pattern\n  ): SelectP<symbols.anonymousSelectKey, input, pattern>;\n  select<p extends Pattern<input>, k extends string>(\n    key: k,\n    pattern: p\n  ): SelectP<k, input, p>;\n} {\n  return {\n    array: array as any,\n    optional: optional as any,\n    intersection: intersection as any,\n    union: union as any,\n    not: not as any,\n    select: select as any,\n    when: when as any,\n  };\n}\n","import { Pattern } from './types/Pattern';\nimport { GuardValue } from './types/helpers';\nimport { Match, PickReturnValue } from './types/Match';\nimport * as symbols from './internals/symbols';\nimport { matchPattern } from './internals/helpers';\n\n/**\n * `match` creates a **pattern matching expression**.\n *\n * Use `.with(pattern, handler)` to pattern match on the input.\n *\n * Use `.exhaustive()` or `.otherwise(() => defaultValue)` to end the expression and get the result.\n *\n * [Read documentation for `match` on GitHub](https://github.com/gvergnaud/ts-pattern#match)\n *\n * @example\n *  declare let input: \"A\" | \"B\";\n *\n *  return match(input)\n *    .with(\"A\", () => \"It's a A!\")\n *    .with(\"B\", () => \"It's a B!\")\n *    .exhaustive();\n *\n */\nexport function match<input extends [any, ...any], output = symbols.unset>(\n  value: input\n): Match<input, output>;\nexport function match<input, output = symbols.unset>(\n  value: input\n): Match<input, output>;\nexport function match<input, output = symbols.unset>(\n  value: input\n): Match<input, output> {\n  return new MatchExpression(value, []) as any;\n}\n\n/**\n * This class represents a match expression. It follows the\n * builder pattern, we chain methods to add features to the expression\n * until we call `.exhaustive`, `.otherwise` or the unsafe `.run`\n * method to execute it.\n *\n * The types of this class aren't public, the public type definition\n * can be found in src/types/Match.ts.\n */\nclass MatchExpression<i, o> {\n  constructor(\n    private value: i,\n    private cases: {\n      match: (value: i) => { matched: boolean; value: any };\n      handler: (...args: any) => any;\n    }[]\n  ) {}\n\n  with(...args: any[]) {\n    const handler = args[args.length - 1];\n\n    const patterns: Pattern<i>[] = [args[0]];\n    const predicates: ((value: i) => unknown)[] = [];\n\n    // case with guard as second argument\n    if (args.length === 3 && typeof args[1] === 'function') {\n      patterns.push(args[0]);\n      predicates.push(args[1]);\n    } else if (args.length > 2) {\n      // case with several patterns\n      patterns.push(...args.slice(1, args.length - 1));\n    }\n\n    return new MatchExpression(\n      this.value,\n      this.cases.concat([\n        {\n          match: (value: i) => {\n            let selected: Record<string, unknown> = {};\n            const matched = Boolean(\n              patterns.some((pattern) =>\n                matchPattern(pattern, value, (key, value) => {\n                  selected[key] = value;\n                })\n              ) && predicates.every((predicate) => predicate(value as any))\n            );\n            return {\n              matched,\n              value:\n                matched && Object.keys(selected).length\n                  ? symbols.anonymousSelectKey in selected\n                    ? selected[symbols.anonymousSelectKey]\n                    : selected\n                  : value,\n            };\n          },\n          handler,\n        },\n      ])\n    );\n  }\n\n  when<p extends (value: i) => unknown, c>(\n    predicate: p,\n    handler: (value: GuardValue<p>) => PickReturnValue<o, c>\n  ) {\n    return new MatchExpression<i, PickReturnValue<o, c>>(\n      this.value,\n      this.cases.concat([\n        {\n          match: (value) => ({\n            matched: Boolean(predicate(value)),\n            value,\n          }),\n          handler,\n        },\n      ])\n    );\n  }\n\n  otherwise<c>(\n    handler: (value: i) => PickReturnValue<o, c>\n  ): PickReturnValue<o, c> {\n    return new MatchExpression<i, PickReturnValue<o, c>>(\n      this.value,\n      this.cases.concat([\n        {\n          match: (value) => ({\n            matched: true,\n            value,\n          }),\n          handler,\n        },\n      ])\n    ).run();\n  }\n\n  exhaustive() {\n    return this.run();\n  }\n\n  run() {\n    let selected = this.value;\n    let handler: undefined | ((...args: any) => any) = undefined;\n\n    for (let i = 0; i < this.cases.length; i++) {\n      const entry = this.cases[i];\n      const matchResult = entry.match(this.value);\n      if (matchResult.matched) {\n        selected = matchResult.value;\n        handler = entry.handler;\n        break;\n      }\n    }\n    if (!handler) {\n      let displayedValue;\n      try {\n        displayedValue = JSON.stringify(this.value);\n      } catch (e) {\n        displayedValue = this.value;\n      }\n      throw new Error(\n        `Pattern matching error: no pattern matches value ${displayedValue}`\n      );\n    }\n    return handler(selected, this.value);\n  }\n}\n","import { Pattern } from './types/Pattern';\nimport { MatchedValue } from './types/Match';\nimport * as P from './patterns';\nimport { matchPattern } from './internals/helpers';\n\n/**\n * `isMatching` takes pattern and returns a **type guard** function, cheching if a value matches this pattern.\n *\n * [Read  documentation for `isMatching` on GitHub](https://github.com/gvergnaud/ts-pattern#ismatching)\n *\n * @example\n *  const hasName = isMatching({ name: P.string })\n *\n *  declare let input: unknown\n *\n *  if (hasName(input)) {\n *    // `input` inferred as { name: string }\n *    return input.name\n *  }\n */\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is MatchedValue<any, P.infer<p>>;\n/**\n * `isMatching` takes pattern and a value and checks if the value matches this pattern.\n *\n * [Read  documentation for `isMatching` on GitHub](https://github.com/gvergnaud/ts-pattern#ismatching)\n *\n * @example\n *  declare let input: unknown\n *\n *  if (isMatching({ name: P.string }, input)) {\n *    // `input` inferred as { name: string }\n *    return input.name\n *  }\n */\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is MatchedValue<any, P.infer<p>>;\n\nexport function isMatching<p extends Pattern<any>>(\n  ...args: [pattern: p, value?: any]\n): boolean | ((vale: any) => boolean) {\n  if (args.length === 1) {\n    const [pattern] = args;\n    return (value: any): value is MatchedValue<any, P.infer<p>> =>\n      matchPattern(pattern, value, () => {});\n  }\n  if (args.length === 2) {\n    const [pattern, value] = args;\n    return matchPattern(pattern, value, () => {});\n  }\n\n  throw new Error(\n    `isMatching wasn't given the right number of arguments: expected 1 or 2, received ${args.length}.`\n  );\n}\n"],"names":["matcher","Symbol","anonymousSelectKey","isObject","value","Boolean","isMatcher","x","symbols","matchPattern","pattern","select","_matcher$match","match","matched","selections","Object","keys","forEach","key","Array","isArray","length","every","subPattern","i","Map","from","get","Set","size","values","v","has","k","matcherType","is","getSelectionKeys","_pattern$symbols$matc","_pattern$symbols$matc2","_pattern$symbols$matc3","call","flatMap","xs","f","reduce","acc","p","concat","optional","_ref","selector","undefined","array","_ref2","intersection","_ref3","patterns","slice","arguments","union","_ref4","some","not","_ref5","when","predicate","_ref6","_ref7","args","_selections","any","_","string","number","boolean","bigint","symbol","nullish","classConstructor","val","isInstanceOf","MatchExpression","cases","this","_proto","prototype","handler","predicates","push","apply","selected","otherwise","run","exhaustive","entry","matchResult","displayedValue","JSON","stringify","e","Error"],"mappings":"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"}