import "./chunk-7U33LM2Z.js";

// node_modules/dino-color-picker/dino-color-picker.js
function t(t2, n2, e2) {
  t2.dispatchEvent(new CustomEvent(n2, { bubbles: true, composed: true, detail: e2 }));
}
var n = class extends HTMLElement {
  constructor() {
    super(), this.__n = /* @__PURE__ */ new Map(), this.root = this.attachShadow({ mode: "open" });
  }
  static get observedAttributes() {
    return ["value"];
  }
  attributeChangedCallback(t2, n2, e2) {
    "value" === t2 && (this.value = e2);
  }
  $(t2) {
    if (this.__n.has(t2))
      return this.__n.get(t2);
    const n2 = this.root.querySelector("#" + t2);
    return this.__n.set(t2, n2), n2;
  }
  $add(t2, n2, e2) {
    "string" == typeof t2 && (t2 = this.$(t2)), t2 && t2.addEventListener(n2, e2);
  }
  $remove(t2, n2, e2) {
    "string" == typeof t2 && (t2 = this.$(t2)), t2 && t2.removeEventListener(n2, e2);
  }
  fire(n2, e2) {
    t(this, n2, e2);
  }
  disconnectedCallback() {
    this.__n.clear();
  }
};
var e = class {
  constructor(t2) {
    this.__n = /* @__PURE__ */ new Map(), this.e = t2, this.root = this.e.attachShadow({ mode: "open" });
  }
  $(t2) {
    if (this.__n.has(t2))
      return this.__n.get(t2);
    const n2 = this.root.querySelector("#" + t2);
    return this.__n.set(t2, n2), n2;
  }
  $add(t2, n2, e2) {
    "string" == typeof t2 && (t2 = this.$(t2)), t2 && t2.addEventListener(n2, e2);
  }
  $remove(t2, n2, e2) {
    "string" == typeof t2 && (t2 = this.$(t2)), t2 && t2.removeEventListener(n2, e2);
  }
  detach() {
    this.__n.clear();
  }
  fire(n2, e2) {
    t(this.e, n2, e2);
  }
};
var i = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAAAAABzHgM7AAAAF0lEQVR42mM4Awb/wYCBYg6EgghRzAEAWDWBGQVyKPMAAAAASUVORK5CYII=";
var s = "0 2px 1px -1px rgba(0,0,0,.2), 0 1px 1px 0 rgba(0,0,0,.14), 0 1px 3px 0 rgba(0,0,0,.12)";
var o = "\ninput[type=range] {\n  width: 100%;\n  height: 100%;\n  box-sizing: border-box;\n  margin: 0;\n  -webkit-appearance: none;\n  background: transparent;\n  outline: none;\n  position: relative;\n  pointer-events: auto;\n  display: block;\n}\ninput[type=range]:focus {\n  outline: none;\n}\ninput[type=range]::-ms-track {\n  width: 100%;\n  cursor: pointer;\n  background: transparent;\n  border-color: transparent;\n  color: transparent;\n}\ninput[type=range]::-moz-focus-outer {\n  outline: none;\n  border: 0;\n}\ninput[type=range]::-moz-range-thumb {\n  border-radius: 50px;\n  background: var(--thumb-color, #ffffff);\n  cursor: pointer;\n  box-shadow: 0 0 4px -1px rgba(0,0,0,0.5);\n  border: 2px solid #fff;\n  margin: 0;\n  height: 20px;\n  width: 20px;\n  transform: scale(0.9);\n  transition: transform 0.18s ease;\n}\ninput[type=range]::-webkit-slider-thumb {\n  -webkit-appearance: none;\n  border-radius: 50px;\n  background: var(--thumb-color, #ffffff);\n  cursor: pointer;\n  box-shadow: 0 0 4px -1px rgba(0,0,0,0.5);\n  height: 22px;\n  width: 22px;\n  margin: 0;\n  border: 2px solid #fff;\n  transform: scale(0.9);\n  transition: transform 0.18s ease;\n}\ninput[type=range]:focus::-moz-range-thumb {\n  box-shadow: 0 5px 5px -3px rgba(0,0,0,.2), 0 8px 10px 1px rgba(0,0,0,.14), 0 3px 14px 2px rgba(0,0,0,.12);\n  transform: scale(1);\n}\ninput[type=range]:focus::-webkit-slider-thumb {\n  box-shadow: 0 5px 5px -3px rgba(0,0,0,.2), 0 8px 10px 1px rgba(0,0,0,.14), 0 3px 14px 2px rgba(0,0,0,.12);\n  transform: scale(1);\n}\n";
var r = class extends e {
  constructor(t2) {
    super(t2), this.handleInput = (t3) => {
      t3.stopPropagation();
      const n2 = +this.$("range").value;
      this.updateThumb(), this.fire("range", { value: n2 });
    }, this.root.innerHTML = `
    <style>
      ${o}
      #container {
        width: 100%;
        box-sizing: border-box;
        height: 12px;
        border-radius: 12px;
        position: relative;
        pointer-events: none;
      }
      #gradient {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        pointer-events: none;
        border-radius: 12px;
        background-image: linear-gradient(to right, hsl(0, 100%, 50%), hsl(60, 100%, 50%), hsl(120, 100%, 50%), hsl(180, 100%, 50%), hsl(240, 100%, 50%), hsl(300, 100%, 50%), hsl(0, 100%, 50%));
        border: 1px solid #e5e5e5;
      }
    </style>
    <div id="container">
      <div id="gradient"></div>
      <input id="range" type="range" min="0" max="360" value="0" aria-label="Hue">
    </div>
    `, this.attach();
  }
  attach() {
    this.$add("range", "input", this.handleInput), this.updateThumb();
  }
  detach() {
    this.$remove("range", "input", this.handleInput), super.detach();
  }
  get value() {
    const t2 = this.$("range");
    return t2 ? +t2.value : 0;
  }
  set value(t2) {
    const n2 = this.$("range");
    n2 && (n2.value = "" + Math.max(0, Math.min(360, t2)), this.updateThumb());
  }
  updateThumb() {
    const t2 = this.$("range");
    t2 && this.e.style.setProperty("--thumb-color", `hsl(${+t2.value}, 100%, 50%)`);
  }
};
function a(t2) {
  let n2 = -1;
  return self.Touch && t2 instanceof Touch ? n2 = t2.identifier : h(t2) && (n2 = t2.pointerId), { id: n2, nativeEvent: t2, clientX: t2.clientX, clientY: t2.clientY };
}
var h = (t2) => self.PointerEvent && t2 instanceof PointerEvent;
var l = class {
  constructor(t2, n2) {
    this.startPointers = [], this.currentPointers = [], this.pointerStart = (t3) => {
      if (0 === t3.button && this.triggerPointerStart(a(t3), t3))
        if (h(t3)) {
          (t3.target && "setPointerCapture" in t3.target ? t3.target : this._e).setPointerCapture(t3.pointerId), this.ael("pointermove", this.move), this.ael("pointerup", this.pointerEnd), this.ael("pointercancel", this.pointerEnd);
        } else
          window.addEventListener("mousemove", this.move), window.addEventListener("mouseup", this.pointerEnd);
    }, this.touchStart = (t3) => {
      for (const n3 of Array.from(t3.changedTouches))
        this.triggerPointerStart(a(n3), t3);
    }, this.move = (t3) => {
      const n3 = "changedTouches" in t3 ? Array.from(t3.changedTouches).map((t4) => a(t4)) : [a(t3)], e2 = [];
      for (const t4 of n3) {
        const n4 = this.currentPointers.findIndex((n5) => n5.id === t4.id);
        -1 !== n4 && (e2.push(t4), this.currentPointers[n4] = t4);
      }
      0 !== e2.length && this._h.onMove(e2, t3);
    }, this._end = (t3, n3) => {
      const e2 = this.currentPointers.findIndex((n4) => n4.id === t3.id);
      return -1 !== e2 && (this.currentPointers.splice(e2, 1), this.startPointers.splice(e2, 1), this._h.onEnd && this._h.onEnd(t3, n3, "touchcancel" === n3.type || "pointercancel" === n3.type), true);
    }, this.pointerEnd = (t3) => {
      if (this._end(a(t3), t3))
        if (h(t3)) {
          if (this.currentPointers.length)
            return;
          this.rel("pointermove", this.move), this.rel("pointerup", this.pointerEnd), this.rel("pointercancel", this.pointerEnd);
        } else
          window.removeEventListener("mousemove", this.move), window.removeEventListener("mouseup", this.pointerEnd);
    }, this.touchEnd = (t3) => {
      for (const n3 of Array.from(t3.changedTouches))
        this._end(a(n3), t3);
    }, this._e = t2, this._h = n2, self.PointerEvent ? this.ael("pointerdown", this.pointerStart) : (this.ael("mousedown", this.pointerStart), this.ael("touchstart", this.touchStart), this.ael("touchmove", this.move), this.ael("touchend", this.touchEnd), this.ael("touchcancel", this.touchEnd));
  }
  ael(t2, n2) {
    this._e.addEventListener(t2, n2);
  }
  rel(t2, n2) {
    this._e.removeEventListener(t2, n2);
  }
  stop() {
    this.rel("pointerdown", this.pointerStart), this.rel("mousedown", this.pointerStart), this.rel("touchstart", this.touchStart), this.rel("touchmove", this.move), this.rel("touchend", this.touchEnd), this.rel("touchcancel", this.touchEnd), this.rel("pointermove", this.move), this.rel("pointerup", this.pointerEnd), this.rel("pointercancel", this.pointerEnd), window.removeEventListener("mousemove", this.move), window.removeEventListener("mouseup", this.pointerEnd);
  }
  triggerPointerStart(t2, n2) {
    return !!this._h.onStart(t2, n2) && (this.currentPointers.push(t2), this.startPointers.push(t2), true);
  }
};
var p = class {
  constructor(t2, n2) {
    this.anchor = [0, 0, 0, 0], this.p = [0, 0], this.pAnchor = [0, 0], this.e = t2, n2 && (this.p = this.clamp(n2)), this.tracker = new l(this.e, this);
  }
  get position() {
    return this.p;
  }
  set position(t2) {
    this.p = this.clamp(t2);
  }
  clamp(t2) {
    return [Math.max(0, Math.min(1, t2[0])), Math.max(0, Math.min(1, t2[1]))];
  }
  onStart(t2, n2) {
    n2.preventDefault();
    const e2 = this.e.getBoundingClientRect();
    this.anchor = [e2.left || e2.x, e2.top || e2.y, e2.width, e2.height];
    const i2 = this.anchor[2], s2 = this.anchor[3], o2 = i2 ? (t2.clientX - this.anchor[0]) / i2 : 0, r2 = s2 ? (t2.clientY - this.anchor[1]) / s2 : 0;
    return this.setPosition(o2, r2), this.pAnchor = [...this.p], this.e.style.cursor = "pointer", true;
  }
  onMove(t2) {
    const n2 = t2[0];
    if (n2) {
      const t3 = this.anchor[2], e2 = this.anchor[3], i2 = t3 ? (n2.clientX - this.anchor[0]) / t3 : 0, s2 = e2 ? (n2.clientY - this.anchor[1]) / e2 : 0;
      this.setPosition(i2, s2);
    }
  }
  onEnd(t2, n2, e2) {
    this.e.style.cursor = "", e2 && this.setPosition(...this.pAnchor);
  }
  moveBy(t2, n2) {
    const { width: e2, height: i2 } = this.e.getBoundingClientRect();
    if (e2 && i2) {
      let [s2, o2] = this.position;
      s2 += t2 / e2, o2 += n2 / i2, this.setPosition(s2, o2);
    }
  }
  setPosition(t2, n2) {
    const [e2, i2] = this.clamp([t2, n2]);
    return (e2 !== this.p[0] || i2 !== this.p[1]) && (this.p = [e2, i2], this.fire(), true);
  }
  fire() {
    this.e.dispatchEvent(new CustomEvent("p-input", { bubbles: true, composed: true, detail: [...this.p] }));
  }
  detach() {
    this.tracker.stop();
  }
};
var u = class extends e {
  constructor(t2) {
    super(t2), this.handleInput = (t3) => {
      t3.stopPropagation(), this.fire("range", { value: this.value });
    }, this.root.innerHTML = `
    <style>
      ${o}
      :host {
        --thumb-color: transparent;
      }
      #container {
        width: 100%;
        box-sizing: border-box;
        height: 12px;
        border-radius: 12px;
        position: relative;
        pointer-events: none;
      }
      #gradient {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        pointer-events: none;
        border-radius: 12px;
        background-image: linear-gradient(to right, var(--alpha-g1, hsla(0, 100%, 50%, 0)), var(--alpha-g2, hsla(0, 100%, 50%, 1)));
      }
      #checker {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        pointer-events: none;
        border-radius: 12px;
        background-image: url(${i});
        background-size: 12px 11px;
      }
    </style>
    <div id="container">
      <div id="checker"></div>
      <div id="gradient" style=""></div>
      <input id="range" type="range" min="0" max="100" value="100" aria-label="Alpha">
    </div>
    `, this.attach();
  }
  attach() {
    this.$add("range", "input", this.handleInput);
  }
  detach() {
    this.$remove("range", "input", this.handleInput), super.detach();
  }
  set hue(t2) {
    this.e.style.setProperty("--alpha-g1", `hsla(${t2}, 100%, 50%, 0)`), this.e.style.setProperty("--alpha-g2", `hsla(${t2}, 100%, 50%, 1)`);
  }
  set hsl(t2) {
    this.e.style.setProperty("--alpha-g1", `hsla(${t2[0]}, ${t2[1]}%, ${t2[2]}%, 0)`), this.e.style.setProperty("--alpha-g2", `hsla(${t2[0]}, ${t2[1]}%, ${t2[2]}%, 1)`);
  }
  get value() {
    const t2 = this.$("range");
    return t2 ? +t2.value / 100 : 0;
  }
  set value(t2) {
    const n2 = this.$("range");
    n2 && (n2.value = "" + 100 * Math.max(0, Math.min(1, t2)));
  }
};
var d = /^hsla\s*\(\s*(\d+.?\d*)\s*,\s*(\d+.?\d*)%\s*,\s*(\d+.?\d*)%\s*,\s*(\d+.?\d*)\s*\)$/i;
var c = /^hsl\s*\(\s*(\d+.?\d*)\s*,\s*(\d+.?\d*)%\s*,\s*(\d+.?\d*)%\s*\)$/i;
var g = /^rgba\s*\(\s*(\d+.?\d*)\s*,\s*(\d+.?\d*)\s*,\s*(\d+.?\d*)\s*,\s*(\d+.?\d*)\s*\)$/i;
var b = /^rgb\s*\(\s*(\d+.?\d*)\s*,\s*(\d+.?\d*)\s*,\s*(\d+.?\d*)\s*\)$/i;
var v = (t2) => `hsl(${t2[0] % 360}, ${t2[1]}%, ${t2[2]}%)`;
function m(t2, n2, e2) {
  t2 %= 360, n2 /= 100, e2 /= 100;
  const i2 = (1 - Math.abs(2 * e2 - 1)) * n2, s2 = i2 * (1 - Math.abs(t2 / 60 % 2 - 1)), o2 = e2 - i2 / 2;
  let r2 = 0, a2 = 0, h2 = 0;
  return [r2, a2, h2] = t2 < 60 ? [i2, s2, 0] : t2 < 120 ? [s2, i2, 0] : t2 < 180 ? [0, i2, s2] : t2 < 240 ? [0, s2, i2] : t2 < 300 ? [s2, 0, i2] : [i2, 0, s2], [Math.round(255 * (r2 + o2)), Math.round(255 * (a2 + o2)), Math.round(255 * (h2 + o2))];
}
function x(t2, n2, e2) {
  t2 /= 255, n2 /= 255, e2 /= 255;
  const i2 = Math.max(t2, n2, e2), s2 = Math.min(t2, n2, e2), o2 = i2 - s2;
  let r2 = 0;
  0 === o2 ? r2 = 0 : i2 === t2 ? r2 = (n2 - e2) / o2 % 6 * 60 : i2 === n2 ? r2 = 60 * ((e2 - t2) / o2 + 2) : i2 === e2 && (r2 = 60 * ((t2 - n2) / o2 + 4));
  const a2 = (i2 + s2) / 2, h2 = 0 === o2 ? 0 : o2 / (1 - Math.abs(2 * a2 - 1));
  return [Math.round((360 + r2) % 360), Math.round(100 * h2), Math.round(100 * a2)];
}
function f(t2, n2, e2, i2) {
  i2 = Math.round(255 * i2);
  let s2 = Math.round(t2).toString(16), o2 = Math.round(n2).toString(16), r2 = Math.round(e2).toString(16), a2 = i2.toString(16);
  return 1 === s2.length && (s2 = "0" + s2), 1 === o2.length && (o2 = "0" + o2), 1 === r2.length && (r2 = "0" + r2), 1 === a2.length && (a2 = "0" + a2), (255 === i2 ? `#${s2}${o2}${r2}` : `#${s2}${o2}${r2}${a2}`).toUpperCase();
}
var $ = ["rgba", "hsla", "hex"];
var y = class extends n {
  constructor() {
    super(), this.colorType = 0, this._hsla = [0, 50, 50, 1], this._rgba = [191, 64, 64, 1], this._hex = "#bf4040", this.onThumbFocus = () => this.$("thumb").classList.add("focused"), this.onThumbBlur = () => this.$("thumb").classList.remove("focused"), this.onThumbKeyDown = (t2) => {
      let n2 = true;
      if (this.rc) {
        switch (t2.code) {
          case "ArrowRight":
            this.rc.moveBy(5, 0);
            break;
          case "ArrowLeft":
            this.rc.moveBy(-5, 0);
            break;
          case "ArrowUp":
            this.rc.moveBy(0, -5);
            break;
          case "ArrowDown":
            this.rc.moveBy(0, 5);
            break;
          case "Escape":
            this.$("triInput").blur();
            break;
          default:
            n2 = false;
        }
      }
      n2 && (t2.preventDefault(), t2.stopPropagation());
    }, this._utp = false, this.handlePlaneInput = () => {
      this.$("thumbInput").focus();
      const [t2, n2] = this.rc.position, e2 = Math.max(0, Math.min(100, Math.round(100 * t2))), i2 = Math.max(0, Math.min(100, Math.round(50 * (2 - t2 - n2))));
      e2 === this._hsla[1] && i2 === this._hsla[2] || (this._hsla[1] = e2, this._hsla[2] = i2, this.onHSLChange());
    }, this.onRGBinput = (t2) => {
      t2.stopPropagation();
      const [n2, e2, i2, s2] = [+this.$("inputR").value, +this.$("inputG").value, +this.$("inputB").value, +this.$("inputA").value], [o2, r2, a2] = x(n2, e2, i2);
      this._rgba = [n2, e2, i2, s2], this._hsla = [o2, r2, a2, s2], this._hex = f(n2, e2, i2, s2), this.updateColor(), this._fire();
    }, this.onHexInput = (t2) => {
      t2.stopPropagation(), this.onHexChange(this.$("inputHex").value.trim());
    }, this.onHSLInput = (t2) => {
      t2.stopPropagation(), this._hsla[0] = Math.round(+this.$("inputH").value), this._hsla[1] = +this.$("inputS").value, this._hsla[2] = +this.$("inputL").value, this._hsla[3] = +this.$("inputA2").value, this.onHSLChange();
    }, this.onColorTypeToggle = () => {
      this.colorType = (this.colorType + 1) % $.length, this.updateColorType();
    }, this.onHueChange = (t2) => {
      let [n2, e2, i2, s2] = this._hsla;
      const o2 = t2.detail.value;
      o2 !== n2 && (n2 = o2, s2 || (s2 = 1), e2 || i2 || (e2 = 75, i2 = 50), this._hsla = [n2, e2, i2, s2], this.onHSLChange());
    }, this.onAlphaChange = (t2) => {
      this._hsla[3] = t2.detail.value, this.onHSLChange();
    }, this.root.innerHTML = `
    <style>
      
* {box-sizing: border-box;}
.horizontal {display: flex; flex-direction: row;}
.vertical {display: flex; flex-direction: column;}
.center {align-items: center;}
.flex {flex: 1;}

      label {display: block; font-size: 11px; text-transform: uppercase; letter-spacing: 0.08em; user-select: none;}
      [hidden] {display: none !important;}
      :host {
        display: inline-block;
        touch-action: none;
        background: #FAFAFA;
        box-shadow: 0 3px 1px -2px rgba(0,0,0,.2), 0 2px 2px 0 rgba(0,0,0,.14), 0 1px 5px 0 rgba(0,0,0,.12);
        width: 240px;
      }
      #base {
        position: relative;
        height: var(--canvas-height, 130px);
      }
      #thumb {
        position: absolute;
        width: 40px;
        height: 40px;
        padding: 10px;
        border-radius: 50%;
        transform: translate3d(-50%, -50%, 0);
        cursor: pointer;
        overflow: hidden;
      }
      .knob {
        position: relative;
        width: 20px;
        height: 20px;
        border: 2px solid #fff;
        box-shadow: ${s};
        border-radius: 50%;
        background: var(--ecp-i-thumb-color);
      }
      #thumb::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        opacity: 0.2;
        background: var(--ecp-i-thumb-shadow-color);
        pointer-events: none;
        transform: scale(0);
        transition: transform 0.18s ease;
      }
      #thumb.focused::before {
        transform: scale(1);
      }
      #base1,
      #base2 {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border: none;
      }
      #base1 {
        background: linear-gradient(to right, #fff 0%, rgba(255, 255, 255, 0) 100%);
      }
      #base2 {
        background: linear-gradient(to bottom, transparent 0%, #000 100%);
      }
      #sliderSection {
        padding: 16px 0;
      }
      #textSection {
        padding: 6px 0 8px 4px;
        color: #808080;
      }
      #colorPreviewPanel {
        box-shadow: ${s};
        border-radius: 50%;
        width: 40px;
        height: 40px;
        margin: 0 4px 0 6px;
        overflow: hidden;
        position: relative;
        background-image: url(${i});
        background-size: 12px 11px;
      }
      #colorPreview {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }
      .cell {
        padding: 0 2px;
      }
      .cellInput {
        width: 100%;
        text-align: center;
        border-radius: 0;
        border: 1px solid #d8d8d8;
        outline: none;
        font-size: 11px;
        letter-spacing: 0.5px;
        padding: 6px 2px;
        margin-bottom: 4px;
        font-family: inherit;
      }
      .cellInput:focus {
        border-color: var(--focus-ring-color, #000);
      }
      input::-webkit-outer-spin-button,
      input::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }
      input[type=number] {
        -moz-appearance:textfield;
      }
      #colorTypeToggle {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        position: relative;
        vertical-align: middle;
        fill: currentcolor;
        stroke: none;
        box-sizing: initial;
        padding: 10px;
        border: 0;
        background: none;
        border-radius: 50%;
        color: inherit;
        cursor: pointer;
        overflow: hidden;
        outline: none;
      }
      #colorTypeToggle::before {
        content: "";
        position: absolute;
        top: 0px;
        left: 0px;
        width: 100%;
        height: 100%;
        opacity: 0;
        pointer-events: none;
        background: currentcolor;
      }
      #colorTypeToggle:focus::before {
        opacity: 0.2;
      }
      svg {
        pointer-events: none;
        display: block;
        width: 24px;
        height: 24px;
        transition: transform 0.3s ease;
      }
      #colorTypeToggle:active svg {
        transform: scale(1.15);
      }
      #alphaPanel{
        margin-top: 18px;
      }
      label {
        text-align: center;
      }
      #thumb input {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border: none;
        cursor: pointer;
        opacity: 0;
        font-size: 16px;
      }

      @media(hover:hover) {
        #colorTypeToggle:hover::before {
          opacity: 0.1;
        }
        #colorTypeToggle:focus:hover::before {
          opacity: 0.2;
        }
      }
    </style>
    <div id="base">
      <div id="base1"></div>
      <div id="base2">
        <div id="thumb">
          <div class="knob"></div>
          <input readonly id="thumbInput" tabindex="1">
        </div>
      </div>
      
    </div>
    <div id="sliderSection" class="horizontal center">
      <div id="colorPreviewPanel">
        <div id="colorPreview"></div>
      </div>
      <div class="vertical flex" style="padding: 0 8px;">
        <div id="huePanel"></div>
        <div id="alphaPanel"></div>
      </div>
    </div>
    <div id="textSection" class="horizontal center">
      <div class="flex">
        <div id="rgba" class="horizontal color-text-panel">
          <div class="flex vertical cell">
            <input id="inputR" type="number" class="cellInput">
            <label>R</label>
          </div>
          <div class="flex vertical cell">
            <input id="inputG" type="number" class="cellInput">
            <label>G</label>
          </div>
          <div class="flex vertical cell">
            <input id="inputB" type="number" class="cellInput">
            <label>B</label>
          </div>
          <div class="flex vertical cell">
            <input id="inputA" step="0.01" type="number" class="cellInput">
            <label>A</label>
          </div>
        </div>
        <div hidden id="hsla" class="horizontal">
          <div class="flex vertical cell">
            <input id="inputH" type="number" class="cellInput">
            <label>H</label>
          </div>
          <div class="flex vertical cell">
            <input id="inputS" type="number" class="cellInput">
            <label>S(%)</label>
          </div>
          <div class="flex vertical cell">
            <input id="inputL" type="number" class="cellInput">
            <label>L(%)</label>
          </div>
          <div class="flex vertical cell">
            <input id="inputA2" step="0.01" type="number" class="cellInput">
            <label>A</label>
          </div>
        </div>
        <div hidden id="hex" class="horizontal">
          <div class="flex vertical cell">
            <input id="inputHex" class="cellInput">
            <label>HEX</label>
          </div>
        </div>
      </div>
      <button id="colorTypeToggle" aria-label="color mode">
        <svg viewBox="0 0 24 24" preserveAspectRatio="xMidYMid meet" focusable="false">
          <g>
            <path d="M12 5.83L15.17 9l1.41-1.41L12 3 7.41 7.59 8.83 9 12 5.83zm0 12.34L8.83 15l-1.41 1.41L12 21l4.59-4.59L15.17 15 12 18.17z"></path>
          </g>
        </svg>
      </button>
      
    </div>
    `;
  }
  connectedCallback() {
    const t2 = this.$("base2");
    this.rc = new p(t2, [0.5, 0.5]), this.$add(t2, "p-input", this.handlePlaneInput);
    const n2 = this.$("huePanel");
    this.hueC = new r(n2), this.$add(n2, "range", this.onHueChange);
    const e2 = this.$("alphaPanel");
    this.alphaC = new u(e2), this.$add(e2, "range", this.onAlphaChange), this.$add("rgba", "change", this.onRGBinput), this.$add("hsla", "change", this.onHSLInput), this.$add("hex", "change", this.onHexInput), this.$add("colorTypeToggle", "click", this.onColorTypeToggle), this.$add("thumbInput", "focus", this.onThumbFocus), this.$add("thumbInput", "blur", this.onThumbBlur), this.$add("thumbInput", "keydown", this.onThumbKeyDown), this.updateColorType(), this.updateThumb(), this.updateColor();
  }
  disconnectedCallback() {
    this._utp = false, this.rc && (this.rc.detach(), this.rc = void 0), this.hueC && (this.hueC.detach(), this.hueC = void 0), this.alphaC && (this.alphaC.detach(), this.alphaC = void 0);
    const t2 = this.$("base2");
    t2 && (this.$remove(t2, "p-input", this.handlePlaneInput), this.$remove("rgba", "change", this.onRGBinput), this.$remove("hsla", "change", this.onHSLInput), this.$remove("hex", "change", this.onHexInput), this.$remove("colorTypeToggle", "click", this.onColorTypeToggle), this.$remove("huePanel", "range", this.onHueChange), this.$remove("alphaPanel", "range", this.onAlphaChange)), this.$remove("thumbInput", "focus", this.onThumbFocus), this.$remove("thumbInput", "blur", this.onThumbBlur), this.$remove("thumbInput", "keydown", this.onThumbKeyDown), super.disconnectedCallback();
  }
  updateColor() {
    const t2 = ((t3) => `hsla(${t3[0] % 360}, ${t3[1]}%, ${t3[2]}%, ${t3[3]})`)(this._hsla), [n2, e2, i2, s2] = this._hsla;
    this.alphaC && (this.alphaC.hue = n2, this.alphaC.value = s2), this.hueC && (this.hueC.value = n2), this.rc && (this.rc.position = [e2 / 100, 2 - i2 / 50 - e2 / 100], this.deferredUpdateThumb()), this.$("inputR").value = "" + this._rgba[0], this.$("inputG").value = "" + this._rgba[1], this.$("inputB").value = "" + this._rgba[2], this.$("inputA").value = "" + s2, this.$("inputH").value = "" + n2, this.$("inputS").value = "" + e2, this.$("inputL").value = "" + i2, this.$("inputA2").value = "" + s2, this.$("inputHex").value = "" + this._hex, this.$("colorPreview").style.background = t2, this.$("base").style.background = v([n2, 100, 50, 1]);
  }
  updateColorType() {
    for (let t2 = 0; t2 < $.length; t2++) {
      const n2 = this.$($[t2]);
      t2 === this.colorType ? n2.removeAttribute("hidden") : n2.setAttribute("hidden", "");
    }
  }
  updateThumb() {
    const t2 = this.$("thumb");
    if (t2 && this.rc) {
      const n2 = this.rc.position;
      t2.style.left = 100 * n2[0] + "%", t2.style.top = 100 * n2[1] + "%", t2.style.setProperty("--ecp-i-thumb-color", v(this._hsla));
      const [e2] = this._hsla;
      t2.style.setProperty("--ecp-i-thumb-shadow-color", v([e2, 100, 60, 1]));
    }
  }
  deferredUpdateThumb() {
    this._utp || (this._utp = true, requestAnimationFrame(() => {
      this._utp && (this.updateThumb(), this._utp = false);
    }));
  }
  onHSLChange() {
    const [t2, n2, e2, i2] = this._hsla, [s2, o2, r2] = m(t2, n2, e2);
    this._rgba = [s2, o2, r2, i2], this._hex = f(s2, o2, r2, i2), this.updateColor(), this._fire();
  }
  onHexChange(t2, n2 = true) {
    this.value = t2, n2 && this._fire();
  }
  _fire() {
    this.fire("change");
  }
  get rgb() {
    return [...this._rgba];
  }
  get hsl() {
    return [...this._hsla];
  }
  get value() {
    return this._hex;
  }
  set value(t2) {
    const n2 = function(t3) {
      let n3 = (t3 = t3.trim()).match(d);
      if (n3) {
        const t4 = +n3[1], e3 = +n3[2], i3 = +n3[3], s3 = +n3[4], [o2, r2, a2] = m(t4, e3, i3);
        return { hex: f(o2, r2, a2, s3), hsla: [t4, e3, i3, s3], rgba: [o2, r2, a2, s3] };
      }
      if (n3 = t3.match(c), n3) {
        const t4 = +n3[1], e3 = +n3[2], i3 = +n3[3], [s3, o2, r2] = m(t4, e3, i3);
        return { hex: f(s3, o2, r2, 1), hsla: [t4, e3, i3, 1], rgba: [s3, o2, r2, 1] };
      }
      if (n3 = t3.match(g), n3) {
        const t4 = +n3[1], e3 = +n3[2], i3 = +n3[3], s3 = +n3[4], [o2, r2, a2] = x(t4, e3, i3);
        return { hex: f(t4, e3, i3, s3), hsla: [o2, r2, a2, s3], rgba: [t4, e3, i3, s3] };
      }
      if (n3 = t3.match(b), n3) {
        const t4 = +n3[1], e3 = +n3[2], i3 = +n3[3], [s3, o2, r2] = x(t4, e3, i3);
        return { hex: f(t4, e3, i3, 1), hsla: [s3, o2, r2, 1], rgba: [t4, e3, i3, 1] };
      }
      let e2 = t3;
      const i2 = e2.lastIndexOf("#");
      i2 >= 0 && (e2 = e2.substring(i2 + 1));
      const s2 = function(t4) {
        switch (t4.length) {
          case 3:
            return [+`0x${t4[0]}${t4[0]}`, +`0x${t4[1]}${t4[1]}`, +`0x${t4[2]}${t4[2]}`, 1];
          case 4:
            return [+`0x${t4[0]}${t4[0]}`, +`0x${t4[1]}${t4[1]}`, +`0x${t4[2]}${t4[2]}`, +`0x${t4[3]}${t4[3]}` / 255];
          case 6:
            return [+`0x${t4[0]}${t4[1]}`, +`0x${t4[2]}${t4[3]}`, +`0x${t4[4]}${t4[5]}`, 1];
          case 8:
            return [+`0x${t4[0]}${t4[1]}`, +`0x${t4[2]}${t4[3]}`, +`0x${t4[4]}${t4[5]}`, +`0x${t4[6]}${t4[7]}` / 255];
        }
        return null;
      }(e2);
      if (s2) {
        const [t4, n4, e3, i3] = s2;
        if (isNaN(t4) || isNaN(n4) || isNaN(e3) || isNaN(i3))
          return null;
        const [o2, r2, a2] = x(t4, n4, e3);
        return { hex: f(t4, n4, e3, i3), hsla: [o2, r2, a2, i3], rgba: [t4, n4, e3, i3] };
      }
      return null;
    }(t2);
    n2 && (this._hsla = [...n2.hsla], this._rgba = [...n2.rgba], this._hex = n2.hex, this.updateColor());
  }
};
customElements.define("dino-color-picker", y);
export {
  y as DinoColorPicker
};
//# sourceMappingURL=dino-color-picker.js.map
