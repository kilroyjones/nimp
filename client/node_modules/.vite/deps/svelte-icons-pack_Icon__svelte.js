import "./chunk-TDRWH72F.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  add_location,
  assign,
  children,
  claim_html_tag,
  claim_svg_element,
  detach_dev,
  dispatch_dev,
  get_spread_update,
  init,
  insert_hydration_dev,
  noop,
  safe_not_equal,
  set_svg_attributes,
  svg_element,
  validate_slots
} from "./chunk-IS3EQ5Z3.js";
import "./chunk-XSLCAIPP.js";
import "./chunk-7U33LM2Z.js";

// node_modules/svelte-icons-pack/Icon.svelte
var file = "node_modules/svelte-icons-pack/Icon.svelte";
function create_fragment(ctx) {
  let svg;
  let html_tag;
  let svg_levels = [
    { width: (
      /*size*/
      ctx[1]
    ) },
    { height: (
      /*size*/
      ctx[1]
    ) },
    { "stroke-width": "0" },
    { class: (
      /*className*/
      ctx[2]
    ) },
    /*src*/
    ctx[0].a,
    /*attr*/
    ctx[4],
    { xmlns: "http://www.w3.org/2000/svg" }
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      html_tag = new HtmlTagHydration(true);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        "stroke-width": true,
        class: true,
        xmlns: true
      });
      var svg_nodes = children(svg);
      html_tag = claim_html_tag(svg_nodes, true);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      set_svg_attributes(svg, svg_data);
      add_location(svg, file, 26, 0, 417);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      html_tag.m(
        /*innerHtml*/
        ctx[3],
        svg
      );
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*innerHtml*/
      8)
        html_tag.p(
          /*innerHtml*/
          ctx2[3]
        );
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        dirty & /*size*/
        2 && { width: (
          /*size*/
          ctx2[1]
        ) },
        dirty & /*size*/
        2 && { height: (
          /*size*/
          ctx2[1]
        ) },
        { "stroke-width": "0" },
        dirty & /*className*/
        4 && { class: (
          /*className*/
          ctx2[2]
        ) },
        dirty & /*src*/
        1 && /*src*/
        ctx2[0].a,
        dirty & /*attr*/
        16 && /*attr*/
        ctx2[4],
        { xmlns: "http://www.w3.org/2000/svg" }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Icon", slots, []);
  let { src } = $$props;
  let { size = "1em" } = $$props;
  let { color = void 0 } = $$props;
  let { title = void 0 } = $$props;
  let { className = "" } = $$props;
  let innerHtml;
  let attr;
  $$self.$$.on_mount.push(function() {
    if (src === void 0 && !("src" in $$props || $$self.$$.bound[$$self.$$.props["src"]])) {
      console.warn("<Icon> was created without expected prop 'src'");
    }
  });
  const writable_props = ["src", "size", "color", "title", "className"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Icon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("src" in $$props2)
      $$invalidate(0, src = $$props2.src);
    if ("size" in $$props2)
      $$invalidate(1, size = $$props2.size);
    if ("color" in $$props2)
      $$invalidate(5, color = $$props2.color);
    if ("title" in $$props2)
      $$invalidate(6, title = $$props2.title);
    if ("className" in $$props2)
      $$invalidate(2, className = $$props2.className);
  };
  $$self.$capture_state = () => ({
    src,
    size,
    color,
    title,
    className,
    innerHtml,
    attr
  });
  $$self.$inject_state = ($$props2) => {
    if ("src" in $$props2)
      $$invalidate(0, src = $$props2.src);
    if ("size" in $$props2)
      $$invalidate(1, size = $$props2.size);
    if ("color" in $$props2)
      $$invalidate(5, color = $$props2.color);
    if ("title" in $$props2)
      $$invalidate(6, title = $$props2.title);
    if ("className" in $$props2)
      $$invalidate(2, className = $$props2.className);
    if ("innerHtml" in $$props2)
      $$invalidate(3, innerHtml = $$props2.innerHtml);
    if ("attr" in $$props2)
      $$invalidate(4, attr = $$props2.attr);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color, src*/
    33) {
      $: {
        $$invalidate(4, attr = {});
        if (color) {
          if (src.a.stroke !== "none") {
            $$invalidate(4, attr.stroke = color, attr);
          }
          if (src.a.fill !== "none") {
            $$invalidate(4, attr.fill = color, attr);
          }
        }
      }
    }
    if ($$self.$$.dirty & /*title, src*/
    65) {
      $: {
        $$invalidate(3, innerHtml = (title ? `<title>${title}</title>` : "") + src.c);
      }
    }
  };
  return [src, size, className, innerHtml, attr, color, title];
}
var Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      src: 0,
      size: 1,
      color: 5,
      title: 6,
      className: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Icon",
      options,
      id: create_fragment.name
    });
  }
  get src() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get className() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set className(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Icon_default = Icon;
export {
  Icon_default as default
};
//# sourceMappingURL=svelte-icons-pack_Icon__svelte.js.map
